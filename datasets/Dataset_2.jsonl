{"contract": "contract NIZIGEN {\n    mapping (address => uint) balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {\n      if(true) {\n          if (balances[msg.sender] < _value) revert();\n          balances[msg.sender] = balances[msg.sender] - _value;\n          assert(msg.sender.call.value(_value)(_data));\n          return true;\n      }\n      return false;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 0}
{"contract": "contract NIZIGEN {\n    mapping (address => uint) balances;\n    function transfer(uint _value, bytes _data) public returns (bool) {\n      if(true) {\n          if (balances[msg.sender] < _value) revert();\n          balances[msg.sender] = balances[msg.sender] - _value;\n          assert(msg.sender.call.value(_value)(_data));\n          return true;\n      }\n      else {\n          return false;\n      }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 1}
{"contract": "contract CrowdsaleWPTByRounds {\n  mapping (address => uint) balances;\n  address wallet;\n  function _forwardFunds() internal {\n     wallet.call.value(msg.value).gas(10000000)();\n     balances[wallet] -= msg.value;\n  }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 2}
{"contract": "contract CrowdsaleWPTByRounds {\n  mapping (address => uint) balances;\n  address wallet;\n  address owner;\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function _forwardFunds() internal onlyOwner {\n     wallet.call.value(msg.value).gas(10000000)();\n     balances[wallet] -= msg.value;\n  }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 3}
{"contract": "contract PoCGame {\n    uint totalDonated = 0;\n    mapping (address => uint) balances;\n    address whale;\n    function donateToWhale(uint256 amount) internal {\n        whale.call.value(amount)();\n        totalDonated += amount;\n        balances[whale] -= amount;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 4}
{"contract": "contract PoCGame {\n    uint totalDonated = 0;\n    mapping (address => uint) balances;\n    address whale;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function donateToWhale(uint256 amount) internal onlyOwner {\n        whale.call.value(amount)();\n        totalDonated += amount;\n        balances[whale] -= amount;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 5}
{"contract": "contract FsTKerWallet {\n  function callContract(address to, bytes data) public payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 6}
{"contract": "contract FsTKerWallet {\n  address owner;\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function callContract(address to, bytes data) public onlyOwner payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 7}
{"contract": "contract POHMO {\n    address admin;\n    mapping (address => uint) balances;\n    function distributeExternal(uint256 _eth) private returns(uint) {\n        uint256 _dev = _eth / 100;\n        if (!address(admin).call.value(_dev)()) {\n            _dev = 0;\n            return balances[admin];\n        }\n        balances[admin] -= _dev;\n        return balances[admin];\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 8}
{"contract": "contract POHMO {\n    address admin;\n    mapping (address => uint) balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function distributeExternal(uint256 _eth) private onlyOwner returns(uint) {\n        uint256 _dev = _eth / 100;\n        if (!address(admin).call.value(_dev)()) {\n            _dev = 0;\n            return balances[admin];\n        }\n        balances[admin] -= _dev;\n        return balances[admin];\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 9}
{"contract": "contract Safe {\n    function unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 10}
{"contract": "contract Kleros {\n    function executeOrder(bytes32 _data, uint _value, address _target) public {\n        _target.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 11}
{"contract": "contract Kleros {\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {\n        _target.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 12}
{"contract": "contract Fomo3d {\n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n    function someFunction() public payable {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 13}
{"contract": "contract Fomo3d {\n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function someFunction() public payable onlyOwner {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 14}
{"contract": "interface FoMo3DlongInterface {\n  function getBuyPrice() public view returns(uint256);\n  function getTimeLeft() public view returns(uint256);\n}\ncontract PwnFoMo3D {\n    FoMo3DlongInterface fomo3d;\n    function gotake() public  {\n        if (fomo3d.getTimeLeft() > 50) { revert(); }\n        address(fomo3d).call.value(fomo3d.getBuyPrice() * 2)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 15}
{"contract": "contract mnyminer {\n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n    function futxMiner() public payable {\n        require(futx.call.value(msg.value)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 16}
{"contract": "contract mnyminer {\n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function futxMiner() public payable onlyOwner {\n        require(futx.call.value(msg.value)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 17}
{"contract": "contract TokedoDaico {\n    address public milestoneSystem;\n    function forwardEther() payable public returns(bool) {\n        require(milestoneSystem.call.value(msg.value)());\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 18}
{"contract": "contract Accounting {\n    struct Account {\n        uint balanceETH;\n        address _to;\n    }\n    function transact(Account storage a, uint _value, bytes data) internal {\n        require(a.balanceETH >= _value);\n        a.balanceETH = a.balanceETH - _value;\n        require(a._to.call.value(_value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 19}
{"contract": "contract Accounting {\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    struct Account {\n        uint balanceETH;\n        address _to;\n    }\n    function transact(Account a, uint _value, bytes data) internal onlyOwner {\n        require(a.balanceETH >= _value);\n        a.balanceETH = a.balanceETH - _value;\n        require(a._to.call.value(_value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 20}
{"contract": "contract IChain {\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n    function finishDistribution() public returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 21}
{"contract": "contract IChain {\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function finishDistribution() public onlyOwner returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 22}
{"contract": "contract DSBaseActor {\n    function tryExec(address target, bytes calldata, uint value) internal returns (bool) {\n        return target.call.value(value)(calldata);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 23}
{"contract": "contract fomo3d {\n    function withdraw() public;\n}\ncontract giveAirdrop {\n    mapping (address => uint) balances;\n    function test() public payable {\n        fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));\n        require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());\n        balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 24}
{"contract": "contract Forwarder {\n    address public parentAddress;\n    function flush() {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 25}
{"contract": "contract Forwarder {\n    address public parentAddress;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function flush() onlyOwner {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 26}
{"contract": "contract HiroyukiCoinDark {\n    mapping(address => uint256) public balanceOf;\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(msg.sender.call.value(0)());\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 27}
{"contract": "contract HiroyukiCoinDark {\n    mapping(address => uint256) public balanceOf;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function transfer(address _to, uint _value, bytes _data) public onlyOwner returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(msg.sender.call.value(0)());\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 28}
{"contract": "contract BancorBuyer {\n    mapping(address => uint256) public balances;\n    function buyInternal(address _exchange, uint256 _value, bytes _data) internal {\n        require(_exchange.call.value(_value)(_data));\n        balances[_exchange] = balances[_exchange] - _value;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 29}
{"contract": "contract BancorBuyer {\n    mapping(address => uint256) public balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function buyInternal(address _exchange, uint256 _value, bytes _data) internal onlyOwner {\n        require(_exchange.call.value(_value)(_data));\n        balances[_exchange] = balances[_exchange] - _value;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 30}
{"contract": "contract CHCommittee {\n    function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {\n        return _to.call.value(_value).gas(_gas)(_code);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 31}
{"contract": "contract ELTWagerLedger {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 32}
{"contract": "contract ELTWagerLedger {\n    mapping (address => mapping (address => uint)) public tokens;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 33}
{"contract": "contract safeSend {\n    bool private txMutex3847834 = false;\n    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n        require(txMutex3847834 == false);\n        txMutex3847834 = true;\n        require(toAddr.call.value(amount)(data));\n        txMutex3847834 = false;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 34}
{"contract": "contract SimpleBet {\n\tbool locked = false;\n\tfunction bet() payable {\n\t\tif ((msg.value == 1 ether) && (!locked)) {\n\t\t\tif (!msg.sender.call.value(2 ether)())\n\t\t\t    locked = true;\n\t\t\t\tthrow;\n\t\t}\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 35}
{"contract": "contract Balancer {\n    function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {\n        return to.call.value(value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 36}
{"contract": "contract Balancer {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {\n        return to.call.value(value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 37}
{"contract": "contract ParcelXToken {\n    function execute(address _to, uint256 _value, bytes _data) external returns (bool){\n        require(_to != address(0));\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 38}
{"contract": "contract ParcelXToken {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n        require(_to != address(0));\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 39}
{"contract": "contract Halo3D {\n    uint totalEthCharityRecieved = 0;\n    uint totalEthCharityCollected = 100;\n    address public giveEthCharityAddress;\n    function payCharity() payable public {\n      uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;\n      if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n         totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n      }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 40}
{"contract": "contract ICOBuyer {\n    address public sale;\n    function buy() {\n        require(sale.call.value(this.balance)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 41}
{"contract": "contract ICOBuyer {\n    address public sale;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function buy() onlyOwner {\n        require(sale.call.value(this.balance)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 42}
{"contract": "contract TokensGate {\n  function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n    require(address(this).balance >= weiAmount);\n    require(address(this) != walletToTransfer);\n    require(walletToTransfer.call.value(weiAmount)());\n  }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 43}
{"contract": "contract ERC827Token {\n    function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {\n        require(_spender != address(this));\n        require(_spender.call.value(msg.value)(_data));\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 44}
{"contract": "contract DividendToken {\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function collectOwedDividends() public onlyOwner returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] -= amount;\n        require(msg.sender.call.value(amount)());\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 45}
{"contract": "contract DividendToken {\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n    function collectOwedDividends() public returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] -= amount;\n        require(msg.sender.call.value(amount)());\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 46}
{"contract": "contract Comptroller {\n    function _errorBuyingTokens() private {\n        require(msg.sender.call.value(msg.value)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 47}
{"contract": "contract AddressProxy {\n    function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {\n        require(_location.call.value(_value).gas(_gas)(_data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 48}
{"contract": "contract CarefulTransfer {\n    function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool success) {\n        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 49}
{"contract": "contract DrainMe {\n    address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\n    function callSecondTarget () public payable {\n        require (msg.value >= 0.005 ether);\n        secondTarget.call.value(msg.value)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 50}
{"contract": "contract DrainMe {\n    address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n    function callFirstTarget () public payable {\n        require (msg.value >= 0.005 ether);\n        firstTarget.call.value(msg.value)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 51}
{"contract": "contract DrainMe {\n    address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function callFirstTarget () public onlyOwner payable {\n        require (msg.value >= 0.005 ether);\n        firstTarget.call.value(msg.value)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 52}
{"contract": "contract Puppet {\n    mapping (uint256 => address) public target;\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 53}
{"contract": "contract BasicCrowdsale {\n    function mintETHRewards(address _contract, uint256 _amount) public {\n        require(_contract.call.value(_amount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 54}
{"contract": "contract PoormansHoneyPot {\n    mapping (address => uint) public balances;\n    function withdraw() public{\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 55}
{"contract": "contract PoormansHoneyPot {\n    mapping (address => uint) public balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw() public onlyOwner {\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 56}
{"contract": "contract BitmarkPaymentGateway {\n    function Pay(address _destination) public payable {\n        require(_destination != 0x0);\n        require(msg.value > 0);\n        _destination.call.value(msg.value / (9) * (8))();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 57}
{"contract": "contract keepMyEther {\n    mapping(address => uint256) public balances;\n    function withdraw() public {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 58}
{"contract": "contract keepMyEther {\n    mapping(address => uint256) public balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw() public onlyOwner {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 59}
{"contract": "contract RipioOracle{\n    function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {\n        return to.call.value(value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 60}
{"contract": "contract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    mapping (address => bool) accountExists;\n    function withdraw(uint amount) public {\n        require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 61}
{"contract": "contract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    mapping (address => bool) accountExists;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint amount) public onlyOwner {\n        require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 62}
{"contract": "contract CrowdsaleProxy {\n    function upgradeToAndCall(address newTarget, bytes data) payable public {\n        require(address(this).call.value(msg.value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 63}
{"contract": "contract BoomerangLiquidity {\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n    Participant[] public participants;\n    uint public payoutOrder = 0;\n    function payout() public {\n        uint balance = address(this).balance;\n        require(balance > 1);\n        uint investment = balance / 2;\n        balance =- investment;\n        while (balance > 0) {\n            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n            if(payoutToSend > 0){\n                participants[payoutOrder].payout -= payoutToSend;\n                balance -= payoutToSend;\n                participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 64}
{"contract": "contract BoomerangLiquidity {\n    address public sk2xContract;\n    function donate() payable public {\n        require(sk2xContract.call.value(msg.value).gas(1000000)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 65}
{"contract": "contract A2ACrowdsale {\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 66}
{"contract": "contract A2ACrowdsale {\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\taddress public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\tfunction mintETHRewards( address _contract, uint256 _amount) public onlyOwner {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 67}
{"contract": "contract HODLWallet {\n    mapping(address => uint256) public balances;\n    uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(amount <= MAX_WITHDRAWAL);\n        require(balances[from] >= amount);\n        balances[from] = balances[from] - amount;\n        from.call.value(amount)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 68}
{"contract": "contract HODLWallet {\n    mapping(address => uint256) public balances;\n    uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function doWithdraw(address from,  uint256 amount) internal onlyOwner {\n        require(amount <= MAX_WITHDRAWAL);\n        require(balances[from] >= amount);\n        balances[from] = balances[from] - amount;\n        from.call.value(amount)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 69}
{"contract": "contract ERC223TokenCompatible {\n    mapping (address => uint) balances;\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n\t\trequire(_value <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender] - _value;\n        balances[_to] = balances[_to] + _value;\n\t    msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 70}
{"contract": "contract AuctusTokenSale {\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance * 40 / 100;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 71}
{"contract": "contract SPRING_BOARD_1_ETH {\n    function Jump() public payable {\n        if(msg.value > 1 ether) {\n            msg.sender.call.value(this.balance);\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 72}
{"contract": "contract AutomobileCyberchainToken {\n    function buy(address recipient, uint256 value) public payable {\n        if (value < msg.value) {\n            require(msg.sender.call.value(msg.value - value)());  \n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 73}
{"contract": "contract SIMPLE_PIGGY_BANK {\n    mapping (address => uint) public Bal;\n    uint public MinSum = 1 ether;\n    function Collect(uint _am) public payable {\n        if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n            msg.sender.call.value(_am);\n            Bal[msg.sender] -= _am;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 74}
{"contract": "contract SIMPLE_PIGGY_BANK {\n    mapping (address => uint) public Bal;\n    uint public MinSum = 1 ether;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function Collect(uint _am) public payable onlyOwner {\n        if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n            msg.sender.call.value(_am);\n            Bal[msg.sender] -= _am;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 75}
{"contract": "contract PIGGY_BANK {\n    mapping (address => uint) public Accounts;\n    function Collect(uint _am) public payable {\n        if(_am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] -= _am;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 76}
{"contract": "contract TokenBank  {\n    mapping (address => uint) public Holders;\n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] > 0) {\n            if(_addr.call.value(_wei)()) {\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 77}
{"contract": "contract LuckyETH {\n    mapping(address => uint) playerPendingWithdrawals;\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 78}
{"contract": "contract LuckyETH {\n    mapping(address => uint) playerPendingWithdrawals;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 79}
{"contract": "contract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 80}
{"contract": "contract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint amount) public onlyOwner {\n        require(accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 81}
{"contract": "contract FREE_FOR_FUN {\n    mapping (address=>uint256) public ExtractDepositTime;\n    function GetFreeEther() public payable {\n        if(ExtractDepositTime[msg.sender] != 0) {\n            msg.sender.call.value(ExtractDepositTime[msg.sender])();\n            ExtractDepositTime[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 82}
{"contract": "contract Owned {\n    function execute(address _dst, uint _value, bytes _data) {\n        _dst.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 83}
{"contract": "contract OwnedUpgradeabilityProxy  {\n    function upgradeToAndCall(bytes data) payable public {\n        require(this.call.value(msg.value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 84}
{"contract": "contract LZLCoin {\n    mapping (address => uint) balances;\n    function eT(address _pd, uint _tkA) returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 85}
{"contract": "contract LZLCoin {\n    mapping (address => uint) balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function eT(address _pd, uint _tkA) onlyOwner returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 86}
{"contract": "contract EtherGet {\n    function getTokens(uint num, address addr) public {\n        for(uint i = 0; i < num; i++){\n            addr.call.value(0)();\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 87}
{"contract": "contract EXPERIMENTAL_ETH_AUCTION {\n    mapping(address => uint) public Bids;\n    function RevokeBid() public payable {\n        uint toTransfer = Bids[msg.sender];\n        Bids[msg.sender] = 0;\n        msg.sender.call.value(toTransfer);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 88}
{"contract": "contract HODLerParadise {\n    mapping (string => uint) parameters;\n    function claim_reward(uint uid) public payable {\n        uint final_reward = 100 + msg.value;\n        if (final_reward > parameters[\"price_poοl\"])\n            final_reward = parameters[\"price_poοl\"];\n        require(msg.sender.call.value(final_reward)());\n        parameters[\"price_poοl\"] -= final_reward;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 89}
{"contract": "contract TokenBank {\n    mapping (address => uint) public Holders;\n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[msg.sender] > 0) {\n            if(Holders[_addr] >= _wei) {\n                _addr.call.value(_wei)();\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 90}
{"contract": "contract TokenBank {\n    mapping (address => uint) public Holders;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {\n        if(Holders[msg.sender] > 0) {\n            if(Holders[_addr] >= _wei) {\n                _addr.call.value(_wei)();\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 91}
{"contract": "contract MultiSigWallet {\n    mapping (uint => Transaction) public transactions;\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n    function executeTransaction(uint transactionId) public {\n        if (transactionId > 0) {\n            Transaction tx = transactions[transactionId];\n            tx.executed = true;\n            if (tx.destination.call.value(tx.value)(tx.data))\n                return;\n            else {\n                tx.executed = false;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 92}
{"contract": "contract ERC223Token {\n  address rx;\n  function transfer(uint value, bytes data) public returns (bool) {\n    if (true) {\n       require(rx.call.value(value)(data));\n    }\n    return true;\n  }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 93}
{"contract": "contract PreSaleFund {\n    address owner = msg.sender;\n    function loggedTransfer(uint amount, address target) payable {\n       if(!target.call.value(amount)()) { throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 94}
{"contract": "contract PreSaleFund {\n    address owner = msg.sender;\n    function loggedTransfer(uint amount, address target) payable {\n       if(msg.sender != address(this)) throw;\n       if(!target.call.value(amount)()) { throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 95}
{"contract": "contract PrivateInvestment {\n    function loggedTransfer(uint amount, address target) {\n        if(!target.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 96}
{"contract": "contract AddressLottery {\n    mapping (address => bool) participated;\n    function participate() payable {\n        require(!participated[msg.sender]);\n        participated[msg.sender] = true;\n        require(msg.sender.call.value(this.balance)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 97}
{"contract": "contract Freebie {\n    address public Owner = msg.sender;\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 98}
{"contract": "contract Payee {\n    uint256 public price;\n    function pay(uint256 count) public payable {\n        assert(msg.value >= price * count);\n        if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 99}
{"contract": "contract PrivateBank {\n    mapping (address => uint) public balances;\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 100}
{"contract": "contract PrivateBank {\n    mapping (address => uint) public balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function CashOut(uint _am) onlyOwner {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 101}
{"contract": "contract InkPublicPresale {\n  function withdrawEther(address _to) public {\n     assert(_to.call.value(this.balance)());\n  }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 102}
{"contract": "contract Tradesman {\n    function genericTransfer(address _to, uint _value, bytes _data) public {\n         require(_to.call.value(_value)(_data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 103}
{"contract": "contract MultiSend {\n    function _safeCall(address _to, uint _amount) internal {\n        require(_to.call.value(_amount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 104}
{"contract": "contract TrustWallet {\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n    }\n    Transaction[] public transactions;\n    function executeTransaction() public {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 105}
{"contract": "contract RNTMultiSigWallet {\n    mapping (uint => WalletTransaction) public transactions;\n    struct WalletTransaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n    function executeTransaction(uint transactionId) public {\n        WalletTransaction storage walletTransaction = transactions[transactionId];\n        walletTransaction.executed = true;\n        if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))\n            return;\n        else {\n            walletTransaction.executed = false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 106}
{"contract": "contract Distribution {\n    address admin;\n    function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n        require(msg.sender == admin);\n        require(to.call.value(value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 107}
{"contract": "contract TrustWallet {\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool execution_successful;\n    }\n    Transaction[] public transactions;\n    function executeTransaction() public{\n        Transaction storage transaction = transactions[transactions.length - 1];\n        transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 108}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(weiAmount > 0);\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 109}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function reject(address _participant) public onlyOwner {\n        uint256 weiAmount = deposited[_participant];\n        require(weiAmount > 0);\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 110}
{"contract": "contract Distribution {\n    address admin;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {\n        require(msg.sender == admin);\n        require(to.call.value(value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 111}
{"contract": "contract PullPaymentCapable {\n    mapping(address => uint256) private payments;\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 112}
{"contract": "contract PullPaymentCapable {\n    mapping(address => uint256) private payments;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawPayments() external onlyOwner returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 113}
{"contract": "contract BullTokenRefundVault {\n    address public wallet;\n    function forwardFunds() public {\n        require(this.balance > 0);\n        wallet.call.value(this.balance)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 114}
{"contract": "contract LPPCampaign{\n    function sendTransaction(address destination, uint value, bytes data) public {\n        require(destination.call.value(value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 115}
{"contract": "contract LPPCampaign{\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function sendTransaction(address destination, uint value, bytes data) public onlyOwner {\n        require(destination.call.value(value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 116}
{"contract": "contract MultiplicatorX4 {\n    address public Owner = msg.sender;\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 117}
{"contract": "contract TelcoinSaleKYCEscrow {\n    mapping(address => uint256) public deposited;\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(weiAmount > 0);\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 118}
{"contract": "contract TransferableMultsig {\n    function execute(address destination, uint value, bytes data) external {\n        require(destination.call.value(value)(data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 119}
{"contract": "contract MergeCoin{\n    function eT(address _pd, uint _etA) returns (bool) {\n        if (!_pd.call.value(_etA)()) revert();\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 120}
{"contract": "contract VVToken {\n\tmapping (bytes32 => Transaction) public Transactions;\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n    function executeTransaction(bytes32 TransHash) public {\n        Transactions[TransHash].executed = true;\n        require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 121}
{"contract": "contract MultiplicatorX3 {\n    address public Owner = msg.sender;\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 122}
{"contract": "contract Campaign{\n    address public beneficiary;\n    function withdrawPayout() public {\n        var _amount = this.balance;\n        require(beneficiary.call.value(_amount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 123}
{"contract": "contract IAMEToken {\n\taddress public devETHDestination;\n\tbool public saleHasEnded;\n\tbool public minCapReached;\n\tfunction endSale() {\n\t\tif (saleHasEnded) revert();\n\t\tif (!minCapReached) revert();\n\t\tif (this.balance > 0) {\n\t\t\tif (!devETHDestination.call.value(this.balance)()) revert();\n\t\t}\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 124}
{"contract": "contract MilestoneTracker {\n    struct Milestone {\n        address paymentSource;\n    }\n    Milestone[] public milestones;\n    function authorizePayment(uint _idMilestone) internal {\n        Milestone milestone = milestones[_idMilestone];\n        if (!milestone.paymentSource.call.value(0)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 125}
{"contract": "contract VVToken {\n    mapping (bytes32 => Transaction) public Transactions;\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n    function executeTransaction(bytes32 TransHash) public {\n\t\tTransactions[TransHash].executed = true;\n        require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 126}
{"contract": "contract DSBaseActor {\n    function tryExec( address target, bytes calldata, uint256 value) internal returns (bool) {\n        return target.call.value(value)(calldata);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 127}
{"contract": "contract JBX {\n    function transfer( address to, bytes data)returns (bool success) {\n        require(to.call.value(0)(data));\n        success = true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 128}
{"contract": "contract DSBaseActor {\n    function tryExec( address target, bytes calldata, uint256 value) internal returns (bool call_ret) {\n        call_ret = target.call.value(value)(calldata);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 129}
{"contract": "contract PreICOProxyBuyer {\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 130}
{"contract": "contract PreICOProxyBuyer {\n    mapping(address => uint) public balances;\n    bool refunded = true;\n    address investor = msg.sender;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function refund() onlyOwner {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 131}
{"contract": "contract MoldCoin {\n    address public founder;\n    function buyRecipient(address recipient) payable {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 132}
{"contract": "contract MoldCoin {\n    address public founder;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function buyRecipient(address recipient) payable onlyOwner {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 133}
{"contract": "contract TokenLab {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        require(tokens[0][msg.sender] >= amount);\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        require(msg.sender.call.value(amount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 134}
{"contract": "contract TokenLab {\n    mapping (address => mapping (address => uint)) public tokens;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint amount) onlyOwner {\n        require(tokens[0][msg.sender] >= amount);\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        require(msg.sender.call.value(amount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 135}
{"contract": "contract Forwarder{\n    address public forwardTo;\n    function () public payable{\n        require(forwardTo.call.value(msg.value)(msg.data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 136}
{"contract": "contract Receiver {\n    address public owner;\n    function test() payable {\n        require(owner.call.value(msg.value)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 137}
{"contract": "contract FiatContract {\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n        require(_to.call.value(_value)(_data));\n        return 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 138}
{"contract": "contract MoldCoin {\n    address public founder;\n    uint public coinAllocation = 20 * 10**8 * 10**2;\n    uint public amountRaised = 0;\n    mapping(address => uint) balances;\n    function buyRecipient(address recipient) payable {\n        uint tokens = msg.value * block.timestamp;\n        require(tokens <= coinAllocation);\n        balances[recipient] = balances[recipient] + tokens;\n        amountRaised = amountRaised + msg.value;\n        if (!founder.call.value(msg.value)()) revert();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 139}
{"contract": "contract SharkProxy{\n    function forward(address _destination, uint256 _value, bytes _data) {\n        assert(_destination.call.value(_value)(_data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 140}
{"contract": "contract MarketPrice {\n    address public sender;\n    address public creator;\n    function execute(address _to, uint _value, bytes _data) external {\n        require(msg.sender == creator);\n        require(_to.call.value(_value)(_data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 141}
{"contract": "contract EtherShot{\n    mapping (address => uint) playerPendingWithdrawals;\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        }\n        else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 142}
{"contract": "contract TradersWallet {\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32) {\n        require(_to.call.value(_value)(_data));\n        return 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 143}
{"contract": "contract generic_holder {\n    function execute(address _to, uint _value, bytes _data) external returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 144}
{"contract": "contract SFTToken {\n\taddress public devETHDestination;\n    function withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 145}
{"contract": "contract SFTToken {\n\taddress public devETHDestination;\n\tbool public minCapReached;\n\taddress owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawFunds() onlyOwner {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 146}
{"contract": "contract DeadMansSwitch {\n\tfunction send(address _to, uint _value, bytes _data) {\n\t\tif (!_to.call.value(_value)(_data)) throw;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 147}
{"contract": "contract BountyHunt {\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n    function claimBounty() {\n        uint balance = bountyAmount[msg.sender];\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount -= balance;\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 148}
{"contract": "contract BountyHunt {\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function claimBounty() onlyOwner {\n        uint balance = bountyAmount[msg.sender];\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount -= balance;\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 149}
{"contract": "contract HUNT {\n\taddress addrcnt;\n    function collect() {\n\t\trequire(addrcnt.call.value(this.balance)(0));\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 150}
{"contract": "contract Escrow {\n    mapping (address => uint) public balances;\n    function claim() {\n        uint balance = balances[msg.sender];\n        require(balance > 0);\n        balances[msg.sender] = 0;\n        bool claimed = msg.sender.call.value(balance)();\n        require(claimed);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 151}
{"contract": "contract TokenStore {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint _amount) {\n        require(tokens[0][msg.sender] >= _amount);\n        tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n        if (!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 152}
{"contract": "contract SENSToken{\n\taddress public devETHDestination;\n\tfunction withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 153}
{"contract": "contract CoinDashBuyer {\n    uint256 public bounty = 1;\n    address public sale;\n    function claim_bounty(){\n        if(!sale.call.value(this.balance - bounty)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 154}
{"contract": "contract Wallet{\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n        if (_value == 0) {\n            require(_to.call.value(_value)(_data));\n            return 0;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 155}
{"contract": "contract Ethex{\n    mapping (bytes32 => uint) public buyOrders;\n    function cancelBuyOrder(address token, uint price) {\n        bytes32 h = sha256(token, price, msg.sender);\n        uint remain = buyOrders[h];\n        delete buyOrders[h];\n        if (!msg.sender.call.value(remain)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 156}
{"contract": "contract PreICOProxyBuyer{\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n    function refund()  {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        delete balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 157}
{"contract": "contract FunFairSale {\n    uint public deadline = 1499436000;\n    address public owner;\n    function withdraw() {\n        if (block.timestamp < deadline) throw;\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 158}
{"contract": "contract FunFairSale {\n    address public owner;\n    function withdraw() {\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 159}
{"contract": "contract TokenPool {\n    uint public rewardPercentage = 30;\n    uint public amountRaised = 100;\n    address public tokenCreateContract;\n    bytes4 tokenCreateFunctionHash;\n    mapping (address => uint) balances;\n    function CreateTokens() {\n        uint amount = amountRaised * (100 - rewardPercentage) / 100;\n        if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n        balances[tokenCreateContract] -= amount;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 160}
{"contract": "contract SmartexInvoice  {\n    function advSend(address _to, uint _value, bytes _data){\n         _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 161}
{"contract": "contract DecentrEx{\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 162}
{"contract": "contract BranchWallet {\n    bool public isRightBranch;\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 163}
{"contract": "contract DAS {\n    Proposal[] public proposals;\n    enum ProposalState { Executed}\n    struct Proposal {\n        address beneficiary;\n        uint256 etherAmount;\n        ProposalState state;\n    }\n    function executeProposal(uint256 _proposalID, bytes _transactionBytecode)  {\n        Proposal p = proposals[_proposalID];\n        p.state = ProposalState.Executed;\n        if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 164}
{"contract": "contract TownCrier {\n    struct Request {  \n        address requester;\n    }\n    Request[2**64] public requests;\n    function withdraw() public {\n        if (msg.sender == requests[0].requester) {\n            if (!requests[0].requester.call.value(this.balance)()) { throw; }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 165}
{"contract": "contract Bakt {\n    struct TX {\n        bool blocked;\n        address to;\n        uint value;\n        bytes data;\n    }\n    TX[256] public pendingTxs;\n    uint public committedEther;\n    uint8 public ptxTail;\n    function sendPending() public returns (bool) {\n        TX memory tx = pendingTxs[ptxTail];\n        if(!tx.blocked) {\n            if(tx.to.call.value(tx.value)(tx.data)) {\n                committedEther -= tx.value;\n                return true;\n            }\n        }\n        return false;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 166}
{"contract": "contract Congress {\n    int256 public majorityMargin;\n    Proposal[] public proposals;\n    struct Proposal {\n        address recipient;\n        uint256 amount;\n        bool    executed;\n        bool    proposalPassed;\n        int256  currentResult;\n    }\n    function executeProposal(uint256 id, bytes transactionBytecode) {\n        Proposal p = proposals[id];\n        if (p.currentResult > majorityMargin) {\n            if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;\n            p.proposalPassed = true;\n        } else {\n            p.proposalPassed = false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 167}
{"contract": "contract Token {\n    function execute(address _dst, uint _value, bytes _data) {\n        _dst.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 168}
{"contract": "contract AddressOwnershipVerification {\n    mapping(address => mapping (address => uint32)) verifications;\n    function revoke(address transactor, address transactee) {\n        uint32 deposit = verifications[transactor][transactee];\n        verifications[transactor][transactee] = 0;\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 169}
{"contract": "contract Blockjack {\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n    address public owner;\n    modifier onlyOwner() {\n        if (msg.sender != owner) throw;\n        _;\n    }\n    function migrateBlockjack() onlyOwner {\n        if (currentBankroll > initialBankroll) {\n          if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 170}
{"contract": "contract EtherprisesLLC {\n    mapping (address => address) public latestSeriesForUser;\n    function () payable {\n        if (latestSeriesForUser[msg.sender] != 0) {\n            if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 171}
{"contract": "contract FDC {\n    address public foundationWallet;\n    function empty() returns (bool) {\n        return foundationWallet.call.value(this.balance)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 172}
{"contract": "contract EtherollCrowdfund{\n    mapping (address => uint) public balanceOf;\n    function calcRefund(address _addressToRefund) internal {\n        uint amount = balanceOf[_addressToRefund];\n        balanceOf[_addressToRefund] = 0;\n        if (amount > 0) {\n            if (_addressToRefund.call.value(amount)()) {\n                return;\n            } else {\n                balanceOf[_addressToRefund] = amount;\n            }\n        } \n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 173}
{"contract": "contract EtherollCrowdfund{\n    mapping (address => uint) public balanceOf;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function calcRefund(address _addressToRefund) internal onlyOwner {\n        uint amount = balanceOf[_addressToRefund];\n        balanceOf[_addressToRefund] = 0;\n        if (amount > 0) {\n            if (_addressToRefund.call.value(amount)()) {\n                return;\n            } else {\n                balanceOf[_addressToRefund] = amount;\n            }\n        } \n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 174}
{"contract": "contract Blockjack {\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n    mapping (address => bool) public isOwner;\n    mapping (address => uint) public balances;\n    modifier onlyOwner {\n        if (!isOwner[msg.sender]) throw;\n        _;\n    }\n    function shareProfits() onlyOwner {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n        currentBankroll -= profit;\n        balances[ADMIN_CONTRACT] -= profit;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 175}
{"contract": "contract Blockjack {\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n    mapping (address => uint) public balances;\n    function shareProfits() {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n        currentBankroll -= profit;\n        balances[ADMIN_CONTRACT] -= profit;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 176}
{"contract": "contract ValueTrader{\n    function buyEther(uint256 amount) {\n        assert(msg.sender.call.value(amount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 177}
{"contract": "contract NinjaToken {\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n    function buy(string _commit) payable {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] -= msg.value;\n        commit[msg.sender] = _commit;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 178}
{"contract": "contract NinjaToken {\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function buy(string _commit) payable onlyOwner {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] -= msg.value;\n        commit[msg.sender] = _commit;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 179}
{"contract": "contract CampaignBeneficiary{\n    address public Resilience;\n    function simulatePathwayFromBeneficiary() public payable {\n        bytes4 buySig = bytes4(sha3(\"buy()\"));\n        if (!Resilience.call.value(msg.value)(buySig)) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 180}
{"contract": "contract Comission{\n    address public ledger;\n    function process(bytes32 _destination) payable returns (bool) {\n        var tax = msg.value / 100;\n        if (!ledger.call.value(tax)()) throw;\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 181}
{"contract": "contract Base {\n    function safeSend(address _recipient, uint _ether) internal returns (bool success_){\n        if(!_recipient.call.value(_ether)()) throw;\n        success_ = true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 182}
{"contract": "contract GMT {\n    function _forward(address _to, bytes _data) internal returns(bool, bool) {\n        if (!_to.call.value(msg.value)(_data)) {\n            return (false, false);\n        }\n        return (true, true);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 183}
{"contract": "contract MultiAccess{\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function multiAccessCallD(address _to, uint _value, bytes _data) external onlyOwner returns(bool) {\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 184}
{"contract": "contract PullPaymentCapable {\n    uint256 private totalBalance;\n    mapping(address => uint256) private payments;\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        totalBalance -= payment;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 185}
{"contract": "contract DaoAccount {\n    address owner;\n\tfunction withdrawEtherOrThrow(uint256 amount) private {\n\t\tbool result = owner.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 186}
{"contract": "contract Wallet {\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n         if (_value == 0) {\n            _to.call.value(_value)(_data);\n            return 0;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 187}
{"contract": "contract CryptoCarbon {\n    function _forward(address _to, bytes _data) internal returns(bool, bool) {\n        if (!_to.call.value(msg.value)(_data)) {\n            return (false, false);\n        }\n        return (true, true);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 188}
{"contract": "contract Safe {\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 189}
{"contract": "contract DaoAccount {\n\tuint256 tokenBalance;  \n    address owner;\n\tuint256 tokenPrice;\n\tfunction withdraw(uint256 tokens) {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokens * tokenPrice)()) throw;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 190}
{"contract": "contract YesNo {\n    address public feeAccount;\n    uint public fee;\n    function redeem(uint tokens) {\n        uint abc = tokens * fee;\n        if (!feeAccount.call.value(abc /(1 ether))()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 191}
{"contract": "contract EtherDelta {\n    mapping (address => mapping (address => uint)) tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 192}
{"contract": "contract Etheropt {\n    struct Account {\n        int capital;\n    }\n    mapping(uint => Account) accounts;\n    mapping(address => uint) accountIDs;\n    function withdrawFunds(uint amount) {\n        if (accountIDs[msg.sender] > 0) {\n          if (int(amount) > 0) {\n            accounts[accountIDs[msg.sender]].capital -= int(amount);\n            msg.sender.call.value(amount)();\n          }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 193}
{"contract": "contract CarefulSenderMixin {\n    function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool) {\n        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 194}
{"contract": "contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\ncontract Ethsplit {\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n    function split(address etcAddress) {\n        if (amIOnTheFork.forked()) {\n            uint fee = msg.value / 100;\n            fees.send(fee);\n            etcAddress.call.value(msg.value)();\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 195}
{"contract": "contract DaoAccount {\n\tuint256 tokenBalance;\n    address owner;\n\taddress daoChallenge;\n\tuint256 tokenPrice;\n\tmodifier onlyOwner() {\n\t    if (daoChallenge != msg.sender) throw;\n\t    _;\n\t}\n\tfunction withdraw(uint256 tokens) onlyOwner {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokenPrice * tokens)()) throw;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 196}
{"contract": "contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\ncontract SellETCSafely {\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    function split(address ethDestination) {\n        if (amIOnTheFork.forked()) {\n            ethDestination.call.value(msg.value)();\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 197}
{"contract": "contract BranchWallet {\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 198}
{"contract": "contract HayekGold{\n    function _forward(address _to, bytes _data) internal {\n        if (!_to.call.value(msg.value)(_data)) { throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 199}
{"contract": "contract DaoChallenge {\n\tfunction withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 200}
{"contract": "contract EtherDelta {\n    mapping (address => mapping (address => uint)) tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n        tokens[0][msg.sender] -= amount;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 201}
{"contract": "contract MyEtherBank {\n    uint256 private _bankDonationsBalance = 0;\n    function BankOwner_WithdrawDonations() public {\n        if (_bankDonationsBalance > 0) {\n            uint256 amount_ = _bankDonationsBalance;\n            _bankDonationsBalance = 0;\n            if (!msg.sender.call.value(amount_)()) { throw; }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 202}
{"contract": "contract OpenDollar {\n    function _forward(address _to, bytes _data) internal returns(bool) {\n        _to.call.value(msg.value)(_data);\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 203}
{"contract": "contract Wallet {\n    mapping (address => uint) m_txs;\n    function confirm(address _h, uint value, byte data) returns (bool) {\n        if (m_txs[_h] != 0) {\n            _h.call.value(value)(data);\n            m_txs[_h] -= value;\n            return true;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 204}
{"contract": "contract ManagedAccount{\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (_recipient.call.value(_amount)()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 205}
{"contract": "contract Order {\n    function sendRobust(address to, uint value) internal {\n        if (value > 0) {\n            if (!to.call.value(value)()) throw;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 206}
{"contract": "contract Wallet {\n    function execute(address _to, uint _value, bytes _data) external returns (uint) {\n        if (_value > 0) {\n            _to.call.value(_value)(_data);\n            return 0;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 207}
{"contract": "contract Bank{\n    mapping (address => uint256) public balances;\n    function withdraw() {\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 208}
{"contract": "contract Owner{\n    mapping (address => uint) private rewardsForA;\n    function untrustedWithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 209}
{"contract": "contract crossFunctionReentrancy{\n    mapping (address => uint) private rewardsForA;\n    function WithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        require(recipient.call.value(amountToWithdraw)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 210}
{"contract": "contract dumbDAO {\n    mapping (address => uint) public balances;\n    function withdraw(address _recipient) returns (bool) {\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 211}
{"contract": "contract EtherStore {\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 212}
{"contract": "contract Reentrance {\n    mapping (address => uint) userBalance;\n    function withdrawBalance_fixed() {\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 213}
{"contract": "contract ReentranceExploit {\n    address public vulnerable_contract;\n    function deposit(address _vulnerable_contract) public payable {\n        vulnerable_contract = _vulnerable_contract ;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 214}
{"contract": "contract SendBalance {\n    mapping (address => uint) userBalances ;\n    function withdrawBalance() {\n        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n        userBalances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 215}
{"contract": "contract SimpleDAO {\n    mapping (address => uint) public credit;\n    function withdraw(uint amount) {\n        if (credit[msg.sender] >= amount) {\n          msg.sender.call.value(amount)();\n          credit[msg.sender] -= amount;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 216}
{"contract": "contract Victim {\n    mapping(address => uint) public balances;\n    function withdraw(uint _amount) public {\n        if(balances[msg.sender] >= _amount) {\n            if(!msg.sender.call.value(_amount)()) { throw; }\n            balances[msg.sender] -= _amount;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 217}
{"contract": "contract PIGGY_BANK {\n    mapping (address => uint) public Accounts;\n    uint public MinSum = 1 ether;\n    uint putBlock;\n    function Collect(uint _am) public payable {\n        if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] -= _am;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 218}
{"contract": "contract BancorBuyer {\n    mapping(address => uint256) public balances;\n    function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n        require(_exchange.call.value(_value)(_data));\n        balances[msg.sender] = balances[msg.sender] - _value;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 219}
{"contract": "contract Bank{\n    mapping (address => uint256) public balances;\n    function withdraw(){\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 220}
{"contract": "contract Attack {\n    address victim;\n    function step1(uint256 amount) payable {\n        if (this.balance >= amount) {\n            victim.call.value(amount)();\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 221}
{"contract": "contract Owner{\n    mapping (address => uint) private rewardsForA;\n    function WithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        require(recipient.call.value(amountToWithdraw)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 222}
{"contract": "contract dumbDAO {\n    mapping (address => uint) public balances;\n    function withdraw(address _recipient) returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 223}
{"contract": "contract Reentrance {\n    mapping (address => uint) userBalance;\n    function withdrawBalance_fixed(){\n        uint amount = userBalance[msg.sender];\n        if(!(msg.sender.call.value(amount)())){ throw; }\n        userBalance[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 224}
{"contract": "contract Private_Bank {\n    mapping (address => uint) public balances;\n    function CashOut(uint _am)  {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 225}
{"contract": "contract Reentrance {\n    mapping (address => uint) userBalance;\n    function withdrawBalance(){\n        if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }\n        userBalance[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 226}
{"contract": "contract Reentrance {\n    mapping(address => uint) public balances;\n    function withdraw(uint _amount) public {\n        if(balances[msg.sender] >= _amount) {\n          if(msg.sender.call.value(_amount)()) {\n             balances[msg.sender] -= _amount;\n          }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 227}
{"contract": "contract Reentrance {\n    mapping (address => uint) userBalance;\n    function withdrawBalance_fixed(){\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 228}
{"contract": "contract ReentranceExploit {\n    address public vulnerable_contract;\n    function deposit(address _vulnerable_contract) public payable{\n        vulnerable_contract = _vulnerable_contract ;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 229}
{"contract": "contract SendBalance {\n    mapping (address => uint) userBalances ;\n    bool withdrawn = false ;\n    function withdrawBalance(){\n        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }\n        userBalances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 230}
{"contract": "contract SimpleDAO {\n    mapping (address => uint) public credit;\n    function withdraw(uint amount) public {\n        if (credit[msg.sender] >= amount) {\n          require(msg.sender.call.value(amount)());\n          credit[msg.sender] -= amount;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 231}
{"contract": "contract SimpleDAO {\n    mapping (address => uint) public credit;\n    function withdraw(uint amount) public {\n        if (credit[msg.sender] >= amount) {\n          credit[msg.sender] -= amount;\n          require(msg.sender.call.value(amount)());\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 232}
{"contract": "contract Victim {\n    mapping(address => uint) public balances;\n    function withdraw(uint _amount) public {\n        if(balances[msg.sender] >= _amount) {\n            if(msg.sender.call.value(_amount)()) {\n                balances[msg.sender] -= _amount;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 233}
{"contract": "contract Tradesman {\n    address public owner;\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {\n         require(_to.call.value(_value)(_data));\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 234}
{"contract": "contract Address {\n    function sendValue(address recipient, uint256 amount) internal {\n        require(this.balance >= amount);\n        bool success = recipient.call.value(amount)();\n        require(success);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 235}
{"contract": "contract BaseWallet {\n    function invoke(address _target, uint _value, bytes _data) external {\n        bool success = _target.call.value(_value)(_data);\n        require(success);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 236}
{"contract": "contract TokenCreation {\n    mapping (address => uint256) balances;\n    uint256 public totalSupply;\n    function refund() {\n        if (msg.sender.call.value(balances[msg.sender])()) {\n            totalSupply -= balances[msg.sender];\n            balances[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 237}
{"contract": "contract EtherDeltaExchange {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 238}
{"contract": "contract HoneyPot {\n    mapping (address => uint) public balances;\n    function get() {\n        if (!msg.sender.call.value(balances[msg.sender])()) { throw; }\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 239}
{"contract": "contract MultiplicatorX3 {\n    function Command(address adr, bytes data) payable public {\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 240}
{"contract": "contract NBUNIERC20 {\n    mapping(address => uint256) private balances;\n    function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public {\n        bool success = msg.sender.call.value(address(this).balance)();\n        balances[msg.sender] = balances[address(this)];\n        balances[address(this)] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 241}
{"contract": "contract Private_Bank {\n    mapping (address => uint) public balances;\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] -= _am;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 242}
{"contract": "contract Reentrance {\n    mapping (address => uint) userBalance;\n    function withdrawBalance(){\n        if( !(msg.sender.call.value(userBalance[msg.sender])()) ){ throw; }\n        userBalance[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 243}
{"contract": "contract ReentranceExploit {\n    address public vulnerable_contract;\n    function deposit(address _vulnerable_contract) public payable {\n        vulnerable_contract = _vulnerable_contract;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 244}
{"contract": "contract Vault {\n    mapping(address => uint) public balances;\n    function redeem() {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 245}
{"contract": "contract Token {\n    mapping (address => uint256) public balances;\n    function withdraw(uint _amount) public {     \n        require(balances[msg.sender] >= _amount);\n        if(msg.sender.call.value(_amount)()) {\n            balances[msg.sender] -= _amount;        \n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 246}
{"contract": "contract Token {\n    mapping (address => uint256) public balances;\n    function withdraw(uint _amount) public {     \n        require(balances[msg.sender] >= _amount);\n        if(msg.sender.call.value(_amount).gas(2000)()) {\n            balances[msg.sender] -= _amount;        \n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 247}
{"contract": "contract Token {\n    mapping (address => uint256) public balances;\n    function withdraw(uint _amount) public {     \n        require(balances[msg.sender] >= _amount);\n        balances[msg.sender] -= _amount;  \n        if(!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 248}
{"contract": "contract Token {\n    mapping (address => uint256) public balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint _amount) public onlyOwner {\n        require(balances[msg.sender] >= _amount);\n        balances[msg.sender] -= _amount;  \n        if(!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 249}
{"contract": "contract SimpleDAO {\n    mapping (address => uint) public credit;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint amount) onlyOwner {\n        if (credit[msg.sender] >= amount) {\n          msg.sender.call.value(amount)();\n          credit[msg.sender] -= amount;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 250}
{"contract": "contract Bank{\n    mapping (address => uint256) public balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw() onlyOwner {\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender]=0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 251}
{"contract": "contract Owner{\n    mapping (address => uint) private rewardsForA;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function untrustedWithdrawReward(address recipient) public onlyOwner {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 252}
{"contract": "contract dumbDAO {\n    mapping (address => uint) public balances;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(address _recipient) onlyOwner returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 253}
{"contract": "contract Reentrance {\n    mapping (address => uint) userBalance;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawBalance_fixed() onlyOwner {\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 254}
{"contract": "contract SendBalance {\n    mapping (address => uint) userBalances ;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawBalance() onlyOwner {\n        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n        userBalances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 255}
{"contract": "contract DividendDistributorv3 {\n    modifier onlyOwner() {\n        if(msg.sender != address(this)) throw;\n        _;\n    }\n    function loggedTransfer(uint amount, address target) onlyOwner {\n        if(!target.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 256}
{"contract": "contract MultiplicatorX3 {\n    function Command(address adr,bytes data) payable public {\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 257}
{"contract": "contract Private_Bank {\n    mapping (address => uint) public balances;\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                balances[msg.sender]-=_am;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 258}
{"contract": "contract NIZIGEN {\n    mapping (address => uint) balances;\n    function transfer(uint _value, bytes _data) public returns (bool) {\n      if (balances[msg.sender] < _value) revert();\n      assert(msg.sender.call.value(_value)(_data));\n      balances[msg.sender] = balances[msg.sender] - _value;\n      return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 259}
{"contract": "contract Accounting {\n    struct Account {\n        uint balanceETH;\n        address _to;\n    }\n    function transact(Account storage a, uint _value, bytes data) internal {\n        require(a.balanceETH >= _value);\n        require(a._to.call.value(_value)(data));\n        a.balanceETH = a.balanceETH - _value;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 260}
{"contract": "contract HiroyukiCoinDark {\n    mapping(address => uint256) public balanceOf;\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        assert(msg.sender.call.value(_value)(_data));\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 261}
{"contract": "contract ELTWagerLedger {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 262}
{"contract": "contract DividendToken {\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected = 0;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function collectOwedDividends() public onlyOwner returns (uint) {\n        uint amount = creditedPoints[msg.sender] / 100;\n        require(msg.sender.call.value(amount)());\n        creditedPoints[msg.sender] -= amount;\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 263}
{"contract": "contract DividendToken {\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected = 0;\n    function collectOwedDividends() public returns (uint) {\n        uint amount = creditedPoints[msg.sender] / 20;\n        require(msg.sender.call.value(amount)());\n        creditedPoints[msg.sender] -= amount;\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 264}
{"contract": "contract BoomerangLiquidity {\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n    Participant[] public participants;\n    uint public payoutOrder = 0;\n    function payout() public {\n        uint balance = address(this).balance;\n        require(balance > 1);\n        uint investment = balance / 2;\n        balance -= investment;\n        while (balance > 0) {\n            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n            if(payoutToSend > 0){\n                participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n                participants[payoutOrder].payout -= payoutToSend;\n                balance -= payoutToSend;\n            }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 265}
{"contract": "contract HODLWallet {\n    mapping(address => uint256) public balances;\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(amount <= 0.002 * 1000000000000000000);\n        require(balances[from] >= amount);\n        from.call.value(amount)();\n        balances[from] = balances[from] - amount;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 266}
{"contract": "contract ERC223TokenCompatible {\n    mapping (address => uint) balances;\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n\t\trequire(_value <= balances[msg.sender]);\n\t\tmsg.sender.call.value(_value)(_data);\n        balances[msg.sender] = balances[msg.sender] - _value;\n\t\treturn true;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 267}
{"contract": "contract AuctusTokenSale {\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance * 40 / 100;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t}\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 268}
{"contract": "contract LuckyETH {\n    mapping(address => uint) playerPendingWithdrawals;\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        if (msg.sender.call.value(withdrawAmount)()) {\n            playerPendingWithdrawals[msg.sender] = 0;\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 269}
{"contract": "contract LZLCoin {\n    mapping (address => uint) balances;\n    function eT(address _pd, uint _tkA) returns (bool) {\n        if (!msg.sender.call.value(_tkA)()) revert();\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        return true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 270}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 271}
{"contract": "contract PullPaymentCapable {\n    mapping(address => uint256) private payments;\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        if (!msg.sender.call.value(payment)()) { throw; }\n        payments[msg.sender] = 0;\n        success = true;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 272}
{"contract": "contract TelcoinSaleKYCEscrow {\n    mapping(address => uint256) public deposited;\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 273}
{"contract": "contract PreICOProxyBuyer {\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n        balances[investor] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 274}
{"contract": "contract MoldCoin {\n    address public founder;\n    uint public coinAllocation = 20 * 10**8 * 10**2;\n    uint public saleTokenSupply = 0;  \n    uint public amountRaised = 0;\n    mapping(address => uint) balances;\n    function buyRecipient(address recipient) payable {\n        uint tokens = msg.value * block.timestamp;\n        require(tokens <= coinAllocation);\n        balances[recipient] = balances[recipient] + tokens;\n        amountRaised = amountRaised + msg.value;\n        if (!founder.call.value(msg.value)()) revert();\n        balances[founder] -= msg.value;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 275}
{"contract": "contract EtherShot{\n    mapping (address => uint) playerPendingWithdrawals;\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        if (msg.sender.call.value(withdrawAmount)()) {\n            playerPendingWithdrawals[msg.sender] = 0;\n            return true;\n        }\n        else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 276}
{"contract": "contract Escrow {\n    mapping (address => uint) public balances;\n    function claim() {\n        uint balance = balances[msg.sender];\n        require(balance > 0);\n        bool claimed = msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 277}
{"contract": "contract AddressOwnershipVerification {\n    mapping(address => mapping (address => uint32)) verifications;\n    function revoke(address transactor, address transactee) {\n        uint32 deposit = verifications[transactor][transactee];\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n        verifications[transactor][transactee] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 278}
{"contract": "contract EtherollCrowdfund{\n    mapping (address => uint) public balanceOf;\n    function calcRefund(address _addressToRefund) internal {\n        uint amount = balanceOf[_addressToRefund];\n        if (amount > 0) {\n            if (_addressToRefund.call.value(amount)()) {\n                balanceOf[_addressToRefund] = 0;\n            } else {\n                balanceOf[_addressToRefund] = amount;\n            }\n        } \n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 279}
{"contract": "contract PullPaymentCapable {\n    mapping(address => uint256) private payments;\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        if (!msg.sender.call.value(payment)()) { throw; }\n        payments[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 1, "idx": 280}
{"contract": "contract HODLWallet {\n    mapping(address => uint256) public balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function doWithdraw(address from,  uint256 amount) internal onlyOwner {\n        require(amount <= 0.002 * 1000000000000000000);\n        require(balances[from] >= amount);\n        from.call.value(amount)();\n        balances[from] = balances[from] - amount;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 281}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function reject(address _participant) public onlyOwner {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 282}
{"contract": "contract generic_holder {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 283}
{"contract": "contract FDC {\n    address public foundationWallet;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function empty() onlyOwner returns(bool) {\n        return foundationWallet.call.value(this.balance)();\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 284}
{"contract": "contract Accounting {\n    struct Account {\n        uint balanceETH;\n        address _to;\n    }\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function transact(Account storage a, uint _value, bytes data) internal onlyOwner {\n        require(a.balanceETH >= _value);\n        require(a._to.call.value(_value)(data));\n        a.balanceETH = a.balanceETH - _value;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 285}
{"contract": "contract Escrow {\n    mapping (address => uint) public balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function claim() onlyOwner {\n        uint balance = balances[msg.sender];\n        msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 286}
{"contract": "contract AddressOwnershipVerification {\n    mapping(address => mapping (address => uint32)) verifications;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function revoke(address transactor, address transactee) onlyOwner {\n        uint32 deposit = verifications[transactor][transactee];\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n        verifications[transactor][transactee] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 287}
{"contract": "contract PreICOProxyBuyer {\n    mapping(address => uint) public balances;\n    bool refunded = true;\n    address investor = msg.sender;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function refund() onlyOwner {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n        balances[investor] = 0;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 288}
{"contract": "contract FunFairSale {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw() onlyOwner {\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 289}
{"contract": "contract BasicCrowdsale {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function mintETHRewards(address _contract, uint256 _amount) public onlyOwner {\n        require(_contract.call.value(_amount)());\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 290}
{"contract": "contract dumbDAO {\n    mapping (address => uint) public balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(address _recipient) onlyOwner returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 291}
{"contract": "contract Reentrance {\n    mapping(address => uint) public balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint _amount) public onlyOwner {\n        if(balances[msg.sender] >= _amount) {\n          if(msg.sender.call.value(_amount)()) {\n             balances[msg.sender] -= _amount;\n          }\n        }\n    }\n}", "vulnerability_type": "reentrancy", "label": 0, "idx": 292}
{"contract": "contract NXX {\n\tfunction addSupportedToken(uint256 _endTime) public returns (bool) {\n\t\trequire(_endTime > block.timestamp);\n\t\treturn true;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 293}
{"contract": "contract Ownable {\n    uint256 public totalAmount;\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        require(block.timestamp < _timestamp);\n        totalAmount = totalAmount + _value;\n        return totalAmount;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 294}
{"contract": "contract CrowdsaleExt {\n    uint public startsAt;\n    enum State {PreFunding, Failure}\n    function getState() public constant returns (State) {\n        if (block.timestamp < startsAt) return State.PreFunding;\n        else return State.Failure;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 295}
{"contract": "contract Fomo {\n    uint256 public airDropTracker_ = 0;\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / (now) )));\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n            return(true);\n        else\n            return(false);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 296}
{"contract": "contract AccessAdmin {\n    uint64 public endDiscountTime = 0;\n    function _buyDiscountTTM(uint256 _value) private {\n        if (block.timestamp <= endDiscountTime) {\n            require(_value == 0.64 ether);\n        }\n        else {\n            require(_value == 0.99 ether);\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 297}
{"contract": "contract ContractiumInterface {\n    function startTime() public view returns (uint256);\n    function endTime() public view returns (uint256);\n}\ncontract ContractiumKrypStrong {\n    ContractiumInterface ctuContract;\n    function preValidatePurchase() internal {\n        uint256 startTime = ctuContract.startTime();\n        uint256 endTime = ctuContract.endTime();\n        require(block.timestamp >= startTime && block.timestamp <= endTime);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 298}
{"contract": "contract ContractiumInterface {\n    function startTime() public view returns (uint256);\n}\ncontract ContractiumKrypStrong {\n    ContractiumInterface ctuContract;\n    function preValidatePurchase() internal {\n        uint256 startTime = ctuContract.startTime();\n        require(block.timestamp >= startTime);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 299}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 300}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n        uint256 parameter;\n    }\n    Proposal public currentProposal;\n    bool public proposalInProgress = false;\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        proposalInProgress = true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 301}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    uint256 constant proposalLife = 7 days;\n    function voteOnProposal(bool voteFor) external {\n        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 302}
{"contract": "contract TokenVesting {\n  uint256 public cliff;\n  function vestedAmount() public view returns (uint256) {\n     if (block.timestamp < cliff) {\n        return cliff;\n     }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 303}
{"contract": "contract TokenVesting {\n  uint256 public start;\n  uint256 public duration;\n  function vestedAmount(address token) public view returns (uint256) {\n    uint256 currentBalance = 100;\n    uint256 totalBalance = currentBalance + 100;\n    if (block.timestamp >= (start + duration)) {\n        return (totalBalance * start);\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 304}
{"contract": "contract IcoRocketFuel {\n    struct Crowdsale {\n        uint256 closingTime;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n    function finalize(address _token) external {\n        require((block.timestamp >= crowdsales[_token].closingTime));\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 305}
{"contract": "contract IcoRocketFuel {\n    enum States {Closed}\n    struct Crowdsale {\n        uint256 closingTime;\n        bool earlyClosure;     \n        States state;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n    function finalize(address _token) external {\n        require(crowdsales[_token].earlyClosure || (block.timestamp >= crowdsales[_token].closingTime));\n        crowdsales[_token].state = States.Closed;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 306}
{"contract": "contract GameCell {\n  mapping(address => TimeLock[2]) public allocations;\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint256 total_lockamount = 0;\n  uint256 total_unlockamount = 0;\n  function subAllocation(address sender) private {\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount + (allocations[sender][0].balance);\n      }\n      else {\n          total_lockamount = total_lockamount + (allocations[sender][1].balance);\n      }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 307}
{"contract": "contract GameCell {\n  mapping(address => TimeLock[]) public allocations;\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint256 total_lockamount = 0;\n  uint256 total_unlockamount = 0;\n  function subAllocation(address sender) private {\n      for (uint j = 0; j < allocations[sender].length; j++) {\n          if (allocations[sender][j].releaseTime < block.timestamp) {\n              total_unlockamount = total_unlockamount + (allocations[sender][j].balance);\n          }\n      }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 308}
{"contract": "contract braggerContract {\n    function random() private view returns (uint8) {\n        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 251);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 309}
{"contract": "contract FreezableToken {\n    uint release;\n    uint balance;\n    function releaseAll() public returns (uint tokens) {\n        while (release > block.timestamp) {\n            tokens += balance;\n            msg.sender.call.value(tokens);\n        }\n        return tokens;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 310}
{"contract": "contract TimedCrowdsale {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 311}
{"contract": "contract CrowdsaleWPTByRounds{\n    uint256 public closingTime;\n    function closeRound() public returns(uint256) {\n        closingTime = block.timestamp + 1;\n        return closingTime;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 312}
{"contract": "contract Saturn {\n    struct LuckyPending {\n        uint64 block;  \n    }\n    LuckyPending[] public luckyPendings;\n    uint256 public luckyPendingIndex;\n    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {\n        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));\n            return _seed > 0;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 313}
{"contract": "contract SnooKarma {\n    uint public totalSupply = 0;\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply + karma;\n        return totalSupply;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 314}
{"contract": "contract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n    function buyTokens() payable returns (bool){\n        require(block.timestamp < deadline && tokenPrice > 0);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 315}
{"contract": "contract FanCrowdsale {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 316}
{"contract": "contract ERC20Like {\n    mapping(address => Account) internal accounts;\n    struct DirectDebitInfo {\n        uint256 startTime;\n    }\n    struct DirectDebit {\n        DirectDebitInfo info;\n        uint256 epoch;\n    }\n    struct Instrument {\n        DirectDebit directDebit;\n    }\n    struct Account {\n        mapping (address => Instrument) instruments;\n    }\n    function withdrawDirectDebit(address debtor) public returns (bool) {\n        Account storage debtorAccount = accounts[debtor];\n        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n        uint256 epoch = (block.timestamp - debit.info.startTime) + 1;\n        uint256 amount = epoch - (debit.epoch);\n        require(amount > 0);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 317}
{"contract": "contract NGOTVesting {\n    uint256 public lockStartTime;\n    mapping(address => uint256) public stageSettings;\n    function vestStage() public view returns(uint256){\n        uint256 stage = block.timestamp - lockStartTime;\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 318}
{"contract": "contract VestingToken {\n  struct Vesting {\n    uint256 start;           \n    uint256 cliff;\n  }\n  mapping(address => Vesting) public vestings;\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n    if (block.timestamp < vesting.start + vesting.cliff) {\n        return block.timestamp;\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 319}
{"contract": "contract VestingToken {\n  struct Vesting {\n    uint256 start;           \n    uint256 totalAmount;\n  }\n  mapping(address => Vesting) public vestings;\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n    uint time = block.timestamp;\n    if (time >= vesting.start) {\n        return vesting.totalAmount * time;\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 320}
{"contract": "contract DVPlock {\n  address public sponsor;\n  mapping (address => uint256) public balances;\n  mapping (address => uint256) public withdrawAmounts;\n  uint256 _amount = 0;\n  uint256 lock_quarter = 0;\n  function release() public returns (bool) {\n    uint256 released_times = block.timestamp / (60*60*24*30*3);\n    if (released_times >= lock_quarter) {\n        _amount = balances[msg.sender];\n    } else {\n        _amount = balances[msg.sender] - (withdrawAmounts[msg.sender] * lock_quarter);\n    }\n    return true;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 321}
{"contract": "contract DVPlock {\n  uint256 public releaseTime;\n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 322}
{"contract": "contract ERC20TokenInterface {\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\n}\ncontract TwoYearDreamTokensVesting {\n    uint256 public vestingStartUnixTimestamp;\n    function initializeVestingFor (address account) external returns (uint256) {\n        vestingStartUnixTimestamp = block.timestamp;\n        return vestingStartUnixTimestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 323}
{"contract": "contract H2OC {\n    uint256 public totalToken;\n    function burn (uint256 _burntAmount) public returns (bool success) {\n    \ttotalToken = totalToken - _burntAmount + block.timestamp;\n    \treturn true;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 324}
{"contract": "contract Token {\n    mapping(address => uint256) public balances;\n    function unfreezeFoundingTeamBalance() public returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 325}
{"contract": "contract Token {\n    address public owner;\n    mapping(address => uint256) public balances;\n    modifier onlyOwner() {\n        require(msg.sender == owner || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8);\n        _;\n    }\n    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 326}
{"contract": "contract Crowdsale {\n    uint256 constant public MAXSALESCAP = 126000 ether;\n    uint256 public weiRaised;\n    enum State { Funded }\n    State public state;\n    function buyTokens() public payable returns (bool success) {\n        if (weiRaised >= MAXSALESCAP || block.timestamp >= MAXSALESCAP) {\n            state = State.Funded;\n        }\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 327}
{"contract": "contract Crowdsale {\n    uint256 constant public STARTDATE = 1533686401;\n    function buyTokens() public payable returns (bool success) {\n        assert(block.timestamp >= STARTDATE);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 328}
{"contract": "contract MLBNFT {\n    uint public isAttached = 10;\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(isAttached > 1) {\n            require(isAttached == 1);\n        } else {\n            isAttached = block.timestamp;\n        }\n        return isAttached;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 329}
{"contract": "contract MLBNFT {\n    uint32 public detachmentTime = 0;\n    uint public isAttached = 10;\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(block.timestamp - isAttached > detachmentTime) {\n            isAttached = 0;\n        } else {\n            require (isAttached == 1);\n        }\n        return isAttached;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 330}
{"contract": "contract RakuRakuEth {\n  function getCurrentTimestamp () external view returns (uint256) {\n    return block.timestamp;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 331}
{"contract": "contract wbcSale {\n    function blockTime() public view returns (uint32) {\n        return uint32(block.timestamp);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 332}
{"contract": "contract IncreasingTokenPriceCrowdsale {\n  uint256 public openingTime = 10;\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - (openingTime);\n    return elapsedTime;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 333}
{"contract": "contract MineralFactory {\n    uint32 public oresLeft;\n    function _getRandomMineralId() private view returns (uint32) {\n        return uint32(uint256(keccak256(block.timestamp, block.difficulty)) % oresLeft);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 334}
{"contract": "contract MineralMarket {\n    mapping(address => uint) internal ownerGemCount;\n    mapping (uint256 => address) public gemIndexToOwner;\n    Gemstone[] public gemstones;\n    struct Gemstone {\n        uint category;\n        string name;\n        uint256 colour;\n        uint64 polishedTime;\n        uint256 price;\n    }\n    address public addressDev;\n    modifier onlyOwner() {\n        require(msg.sender == addressDev);\n        _;\n    }\n    function mintGem(uint _categoryIdx, string _name, uint256 _colour, bool _polished, uint256 _price) onlyOwner external returns (uint) {\n        uint64 stamp = 0;\n        if (_polished) {\n            stamp = uint64(block.timestamp);\n        }\n        Gemstone memory _stone = Gemstone({\n            category : _categoryIdx,\n            name : _name,\n            colour : _colour,\n            polishedTime : stamp,\n            price : _price\n        });\n        uint256 newStoneId = gemstones.push(_stone) - 1;\n        return newStoneId;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 335}
{"contract": "contract Owned {\n    function random() internal view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 336}
{"contract": "contract EscapeMmmEvents {\n    uint256 public airDropTracker_ = 0;\n    function airdrop() private view returns (bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp)));\n        if(seed - (seed / 10000) * (10000) < airDropTracker_) {\n            return true;\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 337}
{"contract": "contract TokenVesting {\n  uint256 public cliff;\n  mapping (address => uint256) public released;\n  function vestedAmount(uint32 _token) public view returns (uint256) {\n    uint256 totalBalance = 100 + released[_token];\n    if (100 < cliff) {\n      return totalBalance * block.timestamp;\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 338}
{"contract": "contract AqwireToken {\n    uint256 public unlockTime;\n    function transfer() public returns (bool) {\n        require(block.timestamp >= unlockTime);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 339}
{"contract": "contract BitSongCrowdsale {\n    address public owner;\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function startDistribution() external onlyOwner() returns (uint256) {\n        require(openingTime == 0);\n        openingTime = block.timestamp;\n        closingTime = openingTime + duration;\n        return closingTime;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 340}
{"contract": "contract BitSongCrowdsale {\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n    function startDistribution() external returns (uint256) {\n        openingTime = block.timestamp;\n        closingTime = openingTime + duration;\n        return closingTime;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 341}
{"contract": "contract FreezableCoin {\n    struct FreezingNode {\n        uint end_stamp;\n        uint num_coins;\n    }\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n    uint total_coins;\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n        for (uint i = 0; i < nodes.length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_coins = total_coins - nodes[i].end_stamp;\n                return total_coins ;\n            }\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 342}
{"contract": "contract TimedCrowdsale {\n    uint openingTime = 0;\n    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {\n        require(_openingTime >= block.timestamp);\n        openingTime = _openingTime;\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 343}
{"contract": "contract Betting {\n    struct chronus_info {\n        uint32  starting_time;\n        uint32  betting_duration;\n        uint32  race_duration;  \n    }\n    chronus_info public chronus;\n    address public owner;\n    modifier onlyOwner {\n        require(owner == msg.sender);\n        _;\n    }\n    function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner external payable returns (uint32) {\n        chronus.starting_time = uint32(block.timestamp);\n        chronus.betting_duration = _bettingDuration;\n        chronus.race_duration = _raceDuration;\n        return chronus.starting_time;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 344}
{"contract": "contract SafeMath1 {\n    function time() public constant returns (uint256) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 345}
{"contract": "contract Ownable1 {\n  uint public startsAt;\n  enum State { PreFunding, Funding}\n  function getState() public constant returns (State) {\n    if (block.timestamp < startsAt) {\n        return State.PreFunding;\n    } else {\n        return State.Funding;\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 346}
{"contract": "contract TokenTimelock {\n  uint256 public token;\n  uint256 public releaseTime;\n  function release() public returns (uint256){\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token * 2;\n    require(amount > 0);\n    return amount;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 347}
{"contract": "contract WorkIt {\n  uint public startDate;\n  uint secondsPerDay = 86400;\n  address public owner;\n  modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n  }\n  function currentDay() public view onlyOwner() returns (uint) {\n    return (block.timestamp - startDate) / secondsPerDay;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 348}
{"contract": "contract WorkIt {\n  uint public startDate;\n  uint secondsPerDay = 86400;\n  function currentDay() public view returns (uint) {\n    return (block.timestamp - startDate) / secondsPerDay;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 349}
{"contract": "contract CryptualProjectToken {\n  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];\n  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];\n  function getCrowdsaleUserCap() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp + (1534935600);\n    uint256 currentCap = 0;\n    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {\n      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])\n        continue;\n      currentCap = crowdsaleUserCaps[i];\n    }\n    return currentCap;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 350}
{"contract": "contract ERC20Basic {\n  function balanceOf(address who) public view returns (uint256);\n}\ncontract TokenVesting {\n  ERC20Basic public token;\n  uint256 public start;\n  uint256 public currentBalance;\n  mapping (address => uint256) public released;\n  uint256 public totalBalance;\n  function vestedAmount() public returns (uint256) {\n    currentBalance = token.balanceOf(this);\n    totalBalance = currentBalance + (released[token]);\n    if (block.timestamp >= start) {\n        return totalBalance;\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 351}
{"contract": "contract AdditionalToken{\n    address public owner;\n    uint256 public maxProportion;\n    uint256 public totalSupply;\n    mapping(uint256 => uint256) public maxAmountPer;\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n        uint256 curTime = block.timestamp;\n        uint256 curTimes = curTime / (31536000);\n        if(maxAmountPer[curTimes] == 0) {\n            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);\n        }\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 352}
{"contract": "contract AdditionalToken{\n    uint256 public maxProportion;\n    uint256 public totalSupply;\n    mapping(uint256 => uint256) public maxAmountPer;\n    function mint(address _to, uint256 _amount) public returns (bool) {\n        uint256 curTime = block.timestamp;\n        uint256 curTimes = curTime / (31536000);\n        if(maxAmountPer[curTimes] == 0) {\n            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);\n        }\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 353}
{"contract": "contract TokenLock {\n    mapping (address => bool) owners;\n    mapping (address => uint256) public lockAmounts;\n    mapping (address => uint256) public releaseTimestamps;\n    function release(address _addr) external returns (bool){\n        require(block.timestamp >= releaseTimestamps[_addr]);\n        lockAmounts[_addr] = 0;\n        releaseTimestamps[_addr] = 0;\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 354}
{"contract": "contract JobsBounty {\n    address public owner;\n    uint public endDate = 0;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawERC20Token() external onlyOwner returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 355}
{"contract": "contract JobsBounty {\n    uint public endDate = 0;\n    function withdrawERC20Token() external returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 356}
{"contract": "contract Bittwatt {\n    function createDate(uint _minutes, uint _seconds) public view returns (uint) {\n        uint currentTimestamp = block.timestamp;\n        currentTimestamp += _seconds;\n        currentTimestamp += 60 * _minutes;\n        return currentTimestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 357}
{"contract": "contract Zmbc{\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n    address public owner;\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice - newSellPrice;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 358}
{"contract": "contract Zmbc{\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice - newSellPrice;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 359}
{"contract": "contract secondContract {\n    uint timeWindow = 18;\n    function BirthdayBoyClickHere() public view returns(string) {\n        uint time = block.timestamp;\n        require(time < timeWindow);\n        return \"Happy Birthday\";\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 360}
{"contract": "contract ERC20Basic {\n  function balanceOf(address who) public view returns (uint256);\n}\ncontract ANBXTimelock {\n  ERC20Basic public token;\n  uint256 public secondReleaseTime;\n  uint256 amount;\n  function release() public returns (bool) {\n    if (block.timestamp >= secondReleaseTime) {\n      amount = token.balanceOf(this);\n      require(amount > 0);\n      secondReleaseTime = 0;\n      return true;\n    }\n    return false;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 361}
{"contract": "contract EcroContract {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawInvestments() external onlyOwner returns (uint) {\n        uint amount = block.timestamp;\n        return amount;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 362}
{"contract": "contract CardsRaffle {\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n  address public owner;\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function drawRandomWinner() public onlyOwner returns (uint256) {\n    uint256 seed = raffleTicketsBought + block.timestamp;\n    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\n    return raffleTicketThatWon;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 363}
{"contract": "contract CardsRaffle {\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n  function drawRandomWinner() public returns (uint256) {\n    uint256 seed = raffleTicketsBought + block.timestamp;\n    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\n    return raffleTicketThatWon;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 364}
{"contract": "contract ETHERlemon {\n    function canPay() internal {\n        msg.sender.send((block.timestamp*1000)*1000*40);   \n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 365}
{"contract": "contract FoMoJP {\n    uint256 public airDropTracker_ = 0;\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now )));\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n            return true;\n        else\n            return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 366}
{"contract": "contract FsTKColdWallet {\n   function today() private view returns (uint256) {\n     return block.timestamp / 1 days;\n   }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 367}
{"contract": "contract MEWCrowdsale {\n    uint256[2] internal signatures;\n    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);\n    function changeWallet(address newWallet) public returns (bool) {\n        uint256 blocktime = block.timestamp;\n        if (msg.sender == SIGN_ADDRESS1) {\n            signatures[0] = blocktime;\n        }\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 368}
{"contract": "contract BasicToken {\n  mapping(address => uint256) public mVestingDays;   \n  mapping(address => uint256) public mVestingBegins;\n  function ComputeVestSpend(address target) public returns (uint256) {\n      int256 vestingDays = int256(mVestingDays[target]);\n      int256 vestingProgress = (int256(block.timestamp) - int256(mVestingBegins[target])) / (int256(24*60*60));\n      if (vestingProgress > vestingDays) {\n          vestingProgress = vestingDays;\n      }\n      return 0;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 369}
{"contract": "contract multiowned {\n    function today() private view returns (uint) {\n        return block.timestamp / 1 days;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 370}
{"contract": "contract daylimit {\n    function today() private view returns (uint) {\n        return block.timestamp / 1 days;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 371}
{"contract": "contract bigBankLittleBank {\n    function _random() private view returns (uint8) {\n        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 2);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 372}
{"contract": "contract MyPurchaseContract {\n  uint256 public startAt;\n  uint256 public stopAt;\n  uint256 public grantAt;\n  function MyPurchaseContrat() public returns (uint256) {\n     startAt = block.timestamp;\n     stopAt = startAt + 60;\n     grantAt = startAt + 120;\n     return startAt + stopAt + grantAt;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 373}
{"contract": "contract MMaker {\n    mapping (uint8 => address) players;\n    uint8 number;\n    function randomtest() internal returns(uint8){\n        uint8 inter = uint8(uint256(keccak256(block.timestamp)) % number);\n        return uint8(uint256(keccak256(players[inter])) % number);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 374}
{"contract": "contract F3d {\n  mapping(uint256 => Round) public rounds;\n  uint256 public currentRound;\n  struct Round {\n      uint256 endTime;      \n  }\n  function remainTime() public view returns (uint256) {\n      uint time = block.timestamp;\n      if (rounds[currentRound].endTime <= time) {\n          return 0;\n      } else {\n          return rounds[currentRound].endTime - time;\n      }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 375}
{"contract": "contract TimedStateMachine {\n    mapping(bytes32 => uint256) private startTime;\n    function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\n        return startTime[_stateId] <= block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 376}
{"contract": "contract FoMo3DWorld {\n    uint256 public airDropTracker_ = 0;      \n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n            return(true);\n        else\n            return(false);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 377}
{"contract": "interface GameOfSwordsInterface {\n    function airDropTracker_() external returns (uint256);\n    function airDropPot_() external returns (uint256);\n    function withdraw() external;\n}\ncontract PonziPwn {\n    GameOfSwordsInterface private fomo3d = GameOfSwordsInterface(0xE7d2c826292CE8bDd5e51Ce44fff4033Be657269);\n    uint256 private blankContractCost = 20000*1000 ;\n    uint256 private pwnContractCost = 250000*1000;\n    bool _canWin = false;\n    address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\n    uint256 _pwnCost = 0;\n    uint256 _seed = 0;\n    uint256 _tracker = fomo3d.airDropTracker_();\n    function checkPwnData() private returns(uint256,address) {\n        while(!_canWin) {\n            _seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));\n            if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n                    _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n                    _pwnCost+= blankContractCost;\n            } else {\n                    _canWin = true;\n                    _pwnCost += pwnContractCost;\n            }\n        }\n        return (_pwnCost,_newSender);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 378}
{"contract": "contract NekoToken {\n    function random() private view returns (uint8) {\n        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 251);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 379}
{"contract": "contract StarmidFreezeTokens {\n\tfunction refundTokens(address _to, uint _amount) public returns(bool) {\n        require(block.timestamp > 1601510400);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 380}
{"contract": "contract wordbot {\n    function random(bytes32 _entropy) internal view returns (uint16) {\n        return uint16(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, _entropy))) % 1024);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 381}
{"contract": "contract Greedy {\n    uint256 public luckybuyTracker_ = 0;\n    function luckyBuy() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));\n        if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_)\n            return(true);\n        else\n            return(false);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 382}
{"contract": "contract OutCloud {\n    uint256 public preico_startdate;\n    uint public bonusCalculationFactor;\n    uint disc;\n    function getCurrentTokenPricepreICO() private returns (uint) {\n        bonusCalculationFactor = (block.timestamp + (preico_startdate)) / (604800);\n        if (bonusCalculationFactor== 0)\n            disc = 30;\n        return disc;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 383}
{"contract": "contract Redenom {\n    address public owner;\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function pay055loyal(address to) public onlyOwner returns(bool success){\n        uint new_amount = 55566600 + (block.timestamp % 100);\n        return true;\n    }\n}  ", "vulnerability_type": "timestamp", "label": 0, "idx": 384}
{"contract": "contract Redenom {\n    function pay055loyal(address to) public returns(bool success){\n        uint new_amount = 55566600 + (block.timestamp % 100);\n        return true;\n    }\n}  ", "vulnerability_type": "timestamp", "label": 0, "idx": 385}
{"contract": "contract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n    function buyTokens() payable {\n        require(block.timestamp < deadline && tokenPrice > 0);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 386}
{"contract": "contract TMTGBaseToken {\n    uint256 public openingTime;\n    struct investor {\n        uint256 _limit;\n    }\n    mapping(address => investor) public searchInvestor;\n    function _timelimitCal() internal view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime - (openingTime);\n        uint256 _result = timeValue / (31 days);\n        return _result;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 387}
{"contract": "contract Basic {\n    uint256 public openingTime;\n    function getLimitPeriod() external view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime - (openingTime);\n        uint256 result = timeValue / (31 days);\n        return result;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 388}
{"contract": "contract SparksterToken{\n\tstruct Group {\n\t\tuint256 startTime;\n\t}\n\tmapping(uint256 => Group) internal groups;\n\tuint256 public openGroupNumber;\n\tfunction purchase() public  payable returns(bool success) {\n\t\tGroup storage openGroup = groups[openGroupNumber];\n\t\tuint256 currentTimestamp = block.timestamp;\n\t\trequire(currentTimestamp >= openGroup.startTime);\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 389}
{"contract": "contract HorseFutures {\n    mapping(bytes32 => address) owner;\n    function sellOffer(uint256 amount, uint256 price, address race, bytes32 horse) external returns (bytes32) {\n        bytes32 id = keccak256(abi.encodePacked(amount,price,race,horse,true,block.timestamp));\n        require(owner[id] == address(0));\n        return id;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 390}
{"contract": "contract DSNote {\n    function time() public constant returns (uint) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 391}
{"contract": "contract TydoIco {\n  uint256[] public bonuses;\n  uint256[] public bonusEnds;\n  function getBonus() public view returns(uint256 _currentBonus) {\n    uint256 curTime = block.timestamp;\n    for(uint8 i = 0; i < bonuses.length; i++) {\n      if(bonusEnds[i] > curTime) {\n        return bonuses[i];\n      }\n    }\n    return 0;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 392}
{"contract": "contract TimedCrowdsale  {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 393}
{"contract": "contract MMOToken{\n    mapping (address => uint256) public lockAddress;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 394}
{"contract": "contract MMOToken{\n    mapping (address => uint256) public lockAddress;\n    function lockTime(address _to,uint256 _value) public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 395}
{"contract": "contract TMTG {\n    uint256 public openingTime;\n    function setOpeningTime() public returns (bool) {\n        openingTime = block.timestamp;\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 396}
{"contract": "contract TMTG {\n    uint256 public openingTime;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function setOpeningTime() onlyOwner public returns(bool) {\n        openingTime = block.timestamp;\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 397}
{"contract": "contract GameTestToken {\n  mapping(address => TimeLock[]) public allocations;\n  struct TimeLock {\n      uint time;\n      uint256 balance;\n  }\n  function subAllocation(address sender) private returns(bool){\n      for (uint j = 0; j < allocations[sender].length; j++) {\n          if (allocations[sender][j].time < block.timestamp) {\n                allocations[sender][j].balance = 0;\n                return true;\n          }\n      }\n      return false;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 398}
{"contract": "contract TokenTimelock {\n  uint256 public releaseTime;\n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 399}
{"contract": "contract ERC20 {\n  function balanceOf(address to) public returns (uint256);\n}\ncontract TokenLocker {\n    ERC20 public token = ERC20(0x611171923b84185e9328827CFAaE6630481eCc7a);\n    uint256 public releaseTimeFund = 1537833600;  \n    uint public ReserveFundAmount = 18600000 ether;\n    function unlockFund () public returns (bool){\n        require(releaseTimeFund <= block.timestamp);\n        require(ReserveFundAmount > 0);\n        uint tokenBalance = token.balanceOf(this);\n        require(tokenBalance >= ReserveFundAmount);\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 400}
{"contract": "contract Eurufly {\n      uint256 public prePreIcoStartAt;\n      address public owner;\n      modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n      }\n    enum STATE{ PREPREICO }\n    STATE public state;\n    function startPrePreIco() public onlyOwner returns (STATE) {\n        prePreIcoStartAt = block.timestamp;\n        state = STATE.PREPREICO;\n        return state;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 401}
{"contract": "contract TokenTimelockVault {\n    mapping(address => TimeEnvoy) internal owners;\n    struct TimeEnvoy {\n        uint releaseTime;\n        uint balance;\n    }\n    function releasableAmount(address _owner) public view returns (uint256){\n        TimeEnvoy storage owner = owners[_owner];\n        if (block.timestamp >= owner.releaseTime) {\n            return owner.balance;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 402}
{"contract": "contract Crowdsale {\n    uint256 public bonusDeliverTime;\n    uint256 public bonusUnsold;\n    function returnBonus() external returns (uint) {\n        require(block.timestamp > bonusDeliverTime);\n        require(bonusUnsold > 0);\n        return bonusUnsold;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 403}
{"contract": "contract COD {\n    mapping(address => uint) balances;\n    function burn (uint256 _burntAmount) public returns (bool success) {\n    \trequire(balances[msg.sender] >= _burntAmount && block.timestamp > 10);\n    \treturn true;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 404}
{"contract": "contract TokenTimelock {\n    uint256 public cliffPeriod;\n    uint256 public chunksAlreadyVested;\n   function release() public returns (uint256){\n    uint256 chunksNeeded = (block.timestamp - (cliffPeriod));\n    if (chunksNeeded > 10) {\n        chunksNeeded = 10;\n    }\n    chunksAlreadyVested = chunksNeeded;\n    return chunksAlreadyVested;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 405}
{"contract": "contract ParkadeCoinCrowdsale {\n  uint256 public firstBonusRate = 1838;\n  uint256 public normalRate = 1470;\n  uint256 public firstBonusEnds = 1535155200;\n  function currentRate() public view returns (uint256) {\n    if (block.timestamp < firstBonusEnds) {\n        return firstBonusRate;\n    }\n    else {\n         return normalRate;\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 406}
{"contract": "contract Lock {\n    mapping(address => uint256) public teamLockTime;\n    function teamAvailable(address _to) internal constant returns (uint256) {\n        uint256 now1 = block.timestamp;\n        uint256 lockTime = teamLockTime[_to];\n        uint256 time = now1 - (lockTime);\n        uint256 percent = 0;\n        if(time >= 365 days) {\n           percent = (time / (30 days)) + (1);\n        }\n        uint256 avail = avail * (percent) / (12) ;\n        return avail;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 407}
{"contract": "contract DSEasyMultisig {\n    struct action {\n        uint confirmations;  \n        uint expiration;  \n    }\n    mapping( uint => action ) actions;\n    function trigger(uint action_id) returns (bool){\n        var a = actions[action_id];\n        if(block.timestamp > a.expiration)\n        {\n            throw;\n        }\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 408}
{"contract": "contract game {\n    mapping (address => uint) readyTime;\n    function view_readyTime(address _address) view public returns(uint _readyTime){\n        uint time = block.timestamp;\n        if (time >= readyTime[_address]){\n            return 0 ;\n        }\n        else{\n            return readyTime[_address] - time ;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 409}
{"contract": "contract RuletkaIo {\n    function random() private view returns (uint256) {\n        return uint256(uint256(keccak256(block.timestamp, block.difficulty)) % 6);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 410}
{"contract": "contract SafeMath1 {\n    function time() internal returns (uint) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 411}
{"contract": "contract IMigrationContract {\n    function ShowTime() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 412}
{"contract": "contract FreyrTokenLocker {\n    uint256 public releaseTime;\n    function secondsRemaining() public constant returns (uint timestamp) {\n        if (block.timestamp < releaseTime)\n            return releaseTime;\n        else\n            return 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 413}
{"contract": "contract ProVisionRaffle {\n    address[] public Raffle_Entries;\n    function random() private view returns (uint8) {\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % Raffle_Entries.length);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 414}
{"contract": "contract JadeCoin {\n  uint256 public nextSnapshotTime;\n  function snapshotDailyGooResearchFunding() external returns (bool){\n    nextSnapshotTime = block.timestamp + 24 hours;\n    return true;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 415}
{"contract": "contract BulletinBoard {\n    struct Message {\n        address sender;\n        string text;\n        uint timestamp;\n        uint amount;\n    }\n    Message[] public messages;\n    function addMessage(string text) public payable returns (bool) {\n        messages.push(Message(msg.sender, text, block.timestamp, msg.value));\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 416}
{"contract": "contract MINEA {\n    uint private randomNumber;\n    mapping (address => uint256) public successesOf;\n    function () external payable {\n        randomNumber += block.timestamp;\n        uint minedAtBlock = uint(block.blockhash(block.number - 1));\n        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber)) % 10000000;\n        if (block.timestamp < minedHashRel) {\n            successesOf[msg.sender]++;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 417}
{"contract": "contract EtherCityConfig {\n    function nowday() private view returns(uint256) {\n        return block.timestamp / 24 hours;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 418}
{"contract": "contract JadeCoin {\n  mapping(address => uint256) public jadeBalance;\n  mapping(address => uint256) public lastJadeSaveTime;  \n  function updatePlayersCoinByOut(address player) external returns (bool){\n    lastJadeSaveTime[player] = block.timestamp;\n    jadeBalance[player] = jadeBalance[player] + 100;\n    return true;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 419}
{"contract": "contract DutchAuction {\n\tevent BidSubmission(\n        address indexed sender,\n        uint amount,\n        uint missingFunds,\n        uint timestamp\n    );\n    function bid() public payable returns (bool){\n        uint missingFunds = 100;\n        BidSubmission(msg.sender, msg.value, missingFunds, block.timestamp);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 420}
{"contract": "contract LemoCoin {\n    struct FreezingNode {\n        uint end_stamp;\n    }\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n    uint total_lemos = 100;\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n        for (uint i = 0; i < nodes.length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_lemos = total_lemos - nodes[i].end_stamp;\n            }\n        }\n        return total_lemos;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 421}
{"contract": "contract XTVToken {\n  uint public endTime;\n  uint public XTVBurned;\n  mapping(address => uint256) balances;\n  function burnTokens() public returns (uint){\n    require(block.timestamp > endTime);\n    uint256 remaining = balances[address(0)];\n    XTVBurned = remaining;\n    return XTVBurned;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 422}
{"contract": "contract CryptualProjectToken {\n  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];\n  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];\n  uint256 currentCap = 0;\n  function getCrowdsaleUserCap() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - (100);\n    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {\n      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])\n        continue;\n      currentCap = crowdsaleUserCaps[i];\n    }\n    return currentCap;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 423}
{"contract": "contract PitEur{\n  mapping(address => uint256) releaseTimes;\n  function isLocked(address _spender) public view returns (bool) {\n    if (releaseTimes[_spender] <= block.timestamp) {\n        return false;\n    }\n    return true;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 424}
{"contract": "contract FENIX {\n    uint256 public ico_startdate;\n    uint bonusCalculationFactor;\n    uint price_tokn;\n    function getCurrentTokenPrice() private returns (uint) {\n        bonusCalculationFactor = (block.timestamp - (ico_startdate)) / (3600);\n        if (bonusCalculationFactor== 0) \n            price_tokn = 70;\n            return price_tokn;\n     }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 425}
{"contract": "contract KcashVesting {\n    uint256 public lockStartTime;\n    mapping(address => uint256) public stageSettings;\n    mapping(address => uint256) public timeLockDurations;\n    function vestStage() public view returns(uint256){\n        uint256 vestingMonths = 100;\n        uint256 stage = (block.timestamp - (lockStartTime)) / (vestingMonths);\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 426}
{"contract": "contract SponsoredItemGooRaffle {\n    uint256 private raffleTicketsBought;\n    uint256 private raffleTicketThatWon;\n    function drawRandomWinner() public returns (uint256) {\n        uint256 seed = raffleTicketsBought + block.timestamp;\n        raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));\n        return raffleTicketThatWon;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 427}
{"contract": "contract GStarCrowdsale {\n    uint256 constant public startTime = 1532260800;\n    uint256 rate = 100;\n    function getRate() public view returns (uint256) {\n        if (block.timestamp <= startTime) {\n            return ((rate / 100) * 120);\n        }\n        return rate;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 428}
{"contract": "contract EtheremonEnergy {\n    struct Energy {\n        uint lastClaim;\n    }\n    mapping(address => Energy) energyData;\n    uint public claimTime = 30 * 60;\n    uint public claimAmount = 1;\n    function getClaimableAmount(address _trainer) constant external returns(uint) {\n        Energy storage energy = energyData[_trainer];\n        uint period = block.timestamp + energy.lastClaim;\n        uint energyAmount = (period / claimTime) * claimAmount;\n        if (energyAmount > claimAmount)\n            energyAmount = claimAmount;\n        return energyAmount;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 429}
{"contract": "contract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function EMGwithdraw(uint256 weiValue) external onlyOwner returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 430}
{"contract": "contract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n    function EMGwithdraw(uint256 weiValue) external returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 431}
{"contract": "contract tipbot {\n    struct transferInStruct{\n        uint256 amount;\n        uint64 time;\n    }\n    mapping(address => uint256) balances;\n    mapping(address => transferInStruct[]) transferIns;\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        uint64 _now = uint64(block.timestamp);\n        transferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));\n        transferIns[_to].push(transferInStruct(uint256(_value),_now));\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 432}
{"contract": "contract Inner4WithEth {\n    uint256 someValue;\n    function doSomething() public payable {\n        someValue = block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 433}
{"contract": "contract CHAltar {\n  uint256 public genesis;\n  function _getCurrentAltarRecordId() internal view returns (uint256) {\n    return (block.timestamp - genesis) / 86400;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 434}
{"contract": "contract Lottery{\n    uint256 winningNumber;\n   function resetLottery() internal returns (bool){\n       winningNumber = uint256(keccak256(block.timestamp, block.difficulty)) % 300;\n       return true;\n   }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 435}
{"contract": "contract YunMint {\n    uint    public cycleCount = 0;\n    uint256 public firstReleaseAmount;\n    uint256 public createTime = 0;\n    function YunMin(address _operator) public returns(uint256){\n        createTime = block.timestamp;\n        cycleCount = createTime;\n        firstReleaseAmount = 200000 * (10 ** 8);\n        return firstReleaseAmount + cycleCount;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 436}
{"contract": "contract TokenOffering {\n    uint256 public startTime;\n    uint256 public endTime;\n    function updateStartTime(uint256 _startTime) public {\n        require(_startTime <= endTime);\n        require(_startTime >= block.timestamp);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 437}
{"contract": "contract Crowdsale {\n  uint public startsAt;\n  function getCurrentFgcCap() public constant returns (uint) {\n    uint timeSinceStart = block.timestamp - (startsAt);\n    uint currentPeriod = timeSinceStart / (1 days) + (1);\n    if (currentPeriod < 2) {\n        return 5000 * 10** currentPeriod;\n    }\n    return 0;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 438}
{"contract": "contract Tokenlock {\n    uint256 public interval;\n    uint256 public releaseTime;\n    function start() external returns (uint256){\n        uint time = block.timestamp;\n        releaseTime = time + interval;\n        return releaseTime;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 439}
{"contract": "contract PGOMonthlyInternalVault {\n    uint256 public cliff;\n    uint256 vested = 0;\n    function vestedAmount() public view returns (uint256) {\n        uint256 timme = block.timestamp;\n        if (timme >= cliff) {\n            uint256 time = timme - (cliff);\n            uint256 elapsedOffsets = time / (21);\n            vested = vested + (elapsedOffsets);\n        }\n        return vested;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 440}
{"contract": "contract Ownable1 {\n    function started() public view returns(bool) {\n        if (block.timestamp >= 100) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 441}
{"contract": "contract DiceRoll {\n    uint64 nextJackpotTime;\n    function createWinner() public {\n        uint64 tmNow = uint64(block.timestamp);\n        require(tmNow >= nextJackpotTime);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 442}
{"contract": "contract dappVolumeAd {\n\tuint256 public purchaseTimestamp;\n\tfunction updateAd() public payable {\n\t\tpurchaseTimestamp = block.timestamp;\n\t\trequire(purchaseTimestamp > 10);\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 443}
{"contract": "contract SimpleBet {\n\tfunction random() view returns (uint8) {\n        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 256);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 444}
{"contract": "contract CrowdsaleRC {\n    uint public createdTimestamp;\n    function CrowdsaleRC () public {\n        createdTimestamp = block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 445}
{"contract": "contract PLCRVoting {\n    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {\n        uint commitEndDate = block.timestamp + (_commitDuration);\n        uint revealEndDate = commitEndDate + (_revealDuration);\n        return revealEndDate;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 446}
{"contract": "contract DSNote {\n    function time() constant returns (uint) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 447}
{"contract": "contract KOIOSTokenSale {\n\tuint256 public startingTimestamp = 1518696000;\n\tuint256 public endingTimestamp = 1521115200;\n\tfunction isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {\n\t\tbool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;\n\t\treturn validTimestamp;\n\t}\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 448}
{"contract": "contract EthTeamContract {\n    uint64 public finishTime;\n    address public feeOwner;\n    function finish() public {\n        require(block.timestamp >= finishTime);\n        feeOwner.transfer(address(this).balance);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 449}
{"contract": "contract ERC20Like {\n    mapping(address => Account) internal accounts;\n      struct DirectDebitInfo {\n        uint256 amount;\n        uint256 startTime;\n        uint256 interval;\n      }\n      struct DirectDebit {\n        DirectDebitInfo info;\n        uint256 epoch;\n      }\n      struct Instrument {\n        uint256 allowance;\n        DirectDebit directDebit;\n      }\n      struct Account {\n        uint256 balance;\n        uint256 nonce;\n        mapping (address => Instrument) instruments;\n      }\n    function withdrawDirectDebit(address debtor) public returns (uint) {\n        Account storage debtorAccount = accounts[debtor];\n        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n        uint256 epoch = (block.timestamp - (debit.info.startTime) / debit.info.interval) + (1);\n        uint256 amount = epoch - (debit.epoch) * (debit.info.amount);\n        return amount;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 450}
{"contract": "contract FsTKColdWallet {\n  function today() private view returns (uint256) {\n    return block.timestamp / 1 days;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 451}
{"contract": "contract DAVToken {\n  bool public paused = false;\n  uint256 public pauseCutoffTime;\n  function pause() public returns(bool) {\n        require(pauseCutoffTime >= block.timestamp);\n        paused = true;\n        return paused;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 452}
{"contract": "contract MuskTokenVault {\n    uint256 public teamTimeLock = 2 * 365 days;\n    uint256 public teamVestingStages = 8;\n    uint256 public lockedAt = 0;\n    function teamVestingStage() public view returns(uint256){\n        uint256 vestingMonths = teamTimeLock / (teamVestingStages);\n        uint256 stage = (block.timestamp - (lockedAt)) / (vestingMonths);\n        if(stage > teamVestingStages){\n            stage = teamVestingStages;\n        }\n        return stage;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 453}
{"contract": "contract ATTRToken  {\n    uint256 public releaseTime = uint256(1536278399);\n    function setReleaseTime(uint256 _time) public returns (bool){\n        require(_time > block.timestamp);\n        releaseTime = _time;\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 454}
{"contract": "contract LescovexERC20 {\n    mapping (address => timeHold) holded;\n    struct timeHold {\n        uint256[] time;\n        uint256 length;\n    }\n    uint256 public holdTime;\n    function holdedOf(address _owner) public view returns (uint256) {\n        uint256 requiredTime = block.timestamp - holdTime;\n        uint256 iValid = 0;                          \n        uint256 iNotValid = holded[_owner].length;\n        if (holded[_owner].time[iValid] >= requiredTime) {\n            return 0;\n        }\n    }\n }", "vulnerability_type": "timestamp", "label": 1, "idx": 455}
{"contract": "contract TokenLock {\n    mapping (uint256 => TokenTimeLockInfo) public locks;\n    struct TokenTimeLockInfo {\n        uint256 unlockTime;\n    }\n    function unlock (uint256 _id) public {\n        TokenTimeLockInfo memory lockInfo = locks[_id];\n        require (lockInfo.unlockTime <= block.timestamp);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 456}
{"contract": "contract ANSAToken {\n   uint256 public tradeStartTime;\n   function hasTrade() public view returns (bool) {\n      return block.timestamp > tradeStartTime;\n   }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 457}
{"contract": "contract KuaiMintableToken {\n    uint256 public lastMintTime = 0;\n    uint256 public createTime;\n    function KuaiMintableToken() public {\n        createTime = block.timestamp;\n        lastMintTime = createTime;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 458}
{"contract": "contract Math {\n    function random(uint256 nonce, int256 min) internal view returns(int256) {\n        return int256(uint256(keccak256(nonce + block.number + block.timestamp + uint256(block.coinbase)))) %  min;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 459}
{"contract": "contract BasicAccessControl {\n    function getRandom(uint _seed) constant public returns(uint) {\n        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 460}
{"contract": "contract TUINETWORK {\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 461}
{"contract": "contract BWService {\n    uint private seed = 42;\n    function random(uint _upper) private returns (uint)  {\n        seed = uint(keccak256(blockhash(block.number - 1), block.coinbase, block.timestamp, seed, address(0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE).balance));\n        return seed % _upper;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 462}
{"contract": "contract BWData {\n    mapping (address => User) private users;\n    struct User {\n        uint creationTime;\n    }\n    function addUser(address _msgSender) public  {\n        User storage user = users[_msgSender];\n        user.creationTime = block.timestamp;\n        require(user.creationTime == 0);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 463}
{"contract": "contract SmartVows {\n    Event[] public lifeEvents;\n    struct Event {\n        uint date;\n        string name;\n        string description;\n        string mesg;\n    }\n    function saveLifeEvent(string name, string description, string mesg) private {\n        lifeEvents.push(Event(block.timestamp, name, description, mesg));\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 464}
{"contract": "contract SuperCountriesEth {\n    uint256 private potVersion = 1;\n    uint256 private timestampLimit = 1528108990;\n\tfunction updateTimestampLimit() internal {\n\t\ttimestampLimit = block.timestamp + (604800) + (potVersion * (28800));\n\t\treturn;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 465}
{"contract": "contract BCVTokenVault {\n    mapping(address => uint256) public timeLocks;\n    mapping(address => uint256) public claimed;\n    function canCollect() public view returns(bool) {\n        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 466}
{"contract": "contract Variation {\n    uint256 randomSeed = 1;\n    function random() internal returns(uint256) {\n        uint256 randomValue = uint256(keccak256(block.timestamp, uint256(randomSeed * block.difficulty)));\n        randomSeed = uint256(randomValue * block.number);\n        return randomSeed;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 467}
{"contract": "contract CopaDelCrypto {\n  address public owner;\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n  uint256 public prizeValue;\n  uint256 public resultsPublishedTime;\n  address[] public players;\n  function CancelGame() public onlyOwner {\n    resultsPublishedTime = block.timestamp;\n    prizeValue = address(this).balance / players.length;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 468}
{"contract": "contract Fluzcoin {\n    uint public launched = 0;  \n    function launch() public returns(uint){\n        launched = block.timestamp;\n        return launched;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 469}
{"contract": "contract ERC20Basic {\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n}\ncontract TokenTimelock {\n  ERC20Basic public token;\n  uint256 public releaseTime;\n  function release() public {\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token.balanceOf(this);\n    require(amount > 0);\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 470}
{"contract": "contract ESS {\n    address public token;\n    mapping (address => uint256) public sold;\n    uint256 public pubEnd = 0;\n    function withdrawPUB() public returns(bool){\n        require(block.timestamp > pubEnd);\n        bool result = token.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender]);\n        return result;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 471}
{"contract": "contract LocalEthereumEscrows {\n    function createEscrow(uint32 _expiry) payable external {\n        require(block.timestamp < _expiry, \"Signature has expired\");\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 472}
{"contract": "contract UniDAGCrowdsale {\n    uint256 public rateFirstRound = 4000;\n\tuint256 public secondRoundTime = 1539129600;\n    function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {\n        if(block.timestamp < secondRoundTime)\n            return _weiAmount * (rateFirstRound);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 473}
{"contract": "contract ProgressiveIndividualCappedCrowdsale {\n    uint public startGeneralSale;\n    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n    uint256 public baseEthCapPerAddress;\n    function getCurrentEthCapPerAddress() public constant returns(uint) {\n        uint time = block.timestamp;\n        uint timeSinceStartInSec = time - (startGeneralSale);\n        uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC) + (1);\n        return 2 ** currentPeriod;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 474}
{"contract": "contract Distribution{\n  uint256 public stageDuration;\n  uint256 public startTime;\n  function getStage() public view returns(uint16) {\n    return uint16(uint256(block.timestamp) - (startTime) / (stageDuration));\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 475}
{"contract": "contract TokenVesting {\n  function calculateVestedTokens(uint256 _tokens,uint256 _vesting,uint256 _start,uint256 _claimed) internal constant returns (uint256) {\n    uint256 time = block.timestamp;\n    if (time < _start) {\n      return 0;\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 476}
{"contract": "contract Crowdsale {\n  function buyTokens() public payable {\n    uint shipAmount = block.timestamp;\n    require(shipAmount > 0);\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 477}
{"contract": "contract ShareXTokenVault {\n    mapping(address => uint256) public timeLocks;\n    mapping(address => uint256) public claimed;\n    function canCollect() public view returns(bool) {\n        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 478}
{"contract": "contract ShareXTokenVault {\n    mapping(address => uint256) public allocations;\n    mapping(address => uint256) public timeLocks;\n    mapping(address => uint256) public claimed;\n    modifier onlyOwner {\n        require(allocations[msg.sender] > 0);\n        _;\n    }\n    function canCollect() public view onlyOwner returns(bool) {\n        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 479}
{"contract": "contract DAVToken {\n  uint256 public pauseCutoffTime;\n  address public owner;\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {\n    require(_pauseCutoffTime >= block.timestamp);\n    pauseCutoffTime = _pauseCutoffTime;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 480}
{"contract": "contract DAVToken {\n  uint256 public pauseCutoffTime;\n  function setPauseCutoffTime(uint256 _pauseCutoffTime)  public {\n    require(_pauseCutoffTime >= block.timestamp);\n    pauseCutoffTime = _pauseCutoffTime;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 481}
{"contract": "contract NokuFlatPlan {\n    uint256 public nextPaymentTime;\n    function payFee() public returns(bool paid) {\n        require(block.timestamp < nextPaymentTime);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 482}
{"contract": "contract Lottery {\n    uint inactivity = 1;\n    function adminIsDead() public {\n        uint time = block.timestamp;\n        if (inactivity == 1) {\n            inactivity == time;\n        }\n        else {\n            uint256 inactivityThreshold = (time - (30 days));\n            assert(inactivityThreshold < time);\n            if (inactivity < inactivityThreshold) {\n                inactivity = 1;\n            }\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 483}
{"contract": "contract Crowdsale {\n  uint256 public openingTime;\n  uint256 public closingTime;\n  bool public paused = false;\n  modifier onlyOwner() {\n    require(!paused);\n    _;\n  }\n  function _preValidatePurchase() internal onlyOwner {\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 484}
{"contract": "contract ArenaPool {\n    function sendArena() external returns (uint64){\n        uint64 nextArenaTime;\n        uint64 tmNow = uint64(block.timestamp);\n        nextArenaTime = tmNow + 21600;\n        return nextArenaTime;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 485}
{"contract": "contract ActionAuctionPlat {\n    struct Auction {\n        uint64 tokenId;\n        uint64 tmStart;\n        uint64 tmSell;       \n    }\n    Auction[] public auctionArray;\n    mapping(uint256 => uint256) public latestAction;\n    uint64 public auctionDuration = 172800;\n    function isOnSale(uint256 _tokenId) external view returns(bool) {\n        uint256 lastIndex = latestAction[_tokenId];\n        if (lastIndex > 0) {\n            Auction storage order = auctionArray[lastIndex];\n            uint64 tmNow = uint64(block.timestamp);\n            if ((order.tmStart + auctionDuration > tmNow) && order.tmSell == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 486}
{"contract": "contract Variation {\n    uint256 public randomSeed;\n    function random() internal returns(uint256) {\n        uint256 randomValue = uint256(keccak256(block.timestamp, uint256(randomSeed * block.difficulty)));\n        randomSeed = uint256(randomValue * block.number);\n        return randomSeed;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 487}
{"contract": "contract Lottery {\n    uint256 entryCounter;\n    function PRNG() internal view returns (uint256) {\n        uint256 initialize1 = block.timestamp;\n        uint256 calc1 =initialize1 * 5;\n        uint256 calc2 = 1 - calc1;\n        uint256 PRN = calc2 % entryCounter;\n        return PRN;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 488}
{"contract": "contract LOTT {\n    uint public rand1;\n    uint8 public rand2;\n    mapping (uint => mapping (uint8 => address)) public map;\n    function place(uint8 cell) external returns (uint){\n        rand1 += uint(msg.sender) + block.timestamp;\n        rand2 -= uint8(msg.sender);\n        return rand2 + rand2;\n     }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 489}
{"contract": "contract MamaToken {\n    uint public openingTime = 1527638401;  \n    uint public closingTime = 1546214399;  \n    function () external payable {\n        require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 490}
{"contract": "contract Lottery{\n    uint256 winningNumber;\n    function resetLottery() internal {\n        winningNumber = uint256(keccak256(block.timestamp, block.difficulty))%300;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 491}
{"contract": "contract RootInBlocks {\n  address public owner;\n  mapping(string => uint) map;\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function put(string hash) public onlyOwner {\n    require(map[hash] == 0);\n    map[hash] = block.timestamp;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 492}
{"contract": "contract Namahecrowdsale{\n    uint256 public openingTime;\n    uint256 public rate = 1000;\n    function getRate() public view returns (uint256) {\n        if (block.timestamp <= (openingTime + (14 days))) {\n            return rate + (200);\n        }\n        return rate;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 493}
{"contract": "contract PartialBasic {\n  uint256 public constant BASE_REWARD = 20000 ether;\n  uint256 private constant PRECISION = 10**18;\n  uint256 public totalNodes;\n  uint256 private rewardTimestamp;\n  function rewardPerNode() public view returns (uint256) {\n    uint256 totalDays = block.timestamp - (rewardTimestamp) * (PRECISION) / (1 days);\n    uint256 newReward = BASE_REWARD * (totalDays) / (PRECISION) / (totalNodes);\n    return totalDays + (newReward);\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 494}
{"contract": "contract PLCRVoting {\n    struct Poll {\n        uint commitEndDate;      \n        uint revealEndDate;      \n        uint voteQuorum;\t     \n        uint votesFor;\t\t     \n        uint votesAgainst;\n    }\n    uint public pollNonce;\n    mapping(uint => Poll) public pollMap;\n    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n        uint commitEndDate = block.timestamp + (_commitDuration);\n        uint revealEndDate = commitEndDate + (_revealDuration);\n        pollMap[pollNonce] = Poll({\n            voteQuorum: _voteQuorum,\n            commitEndDate: commitEndDate,\n            revealEndDate: revealEndDate,\n            votesFor: 0,\n            votesAgainst: 0\n        });\n        return pollNonce;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 495}
{"contract": "contract NeuroChainClausius {\n  event FreezeStatusChanged(bool toStatus, uint timestamp);\n  bool public tradingLive = false;\n  function setTradingStatus(bool isLive) public {\n    tradingLive = isLive;\n    FreezeStatusChanged(tradingLive, block.timestamp);\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 496}
{"contract": "contract SPCoin {\n    uint256 public pre_startdate;\n    uint bonusCalculationFactor;\n    function bonuscalpre() private returns (uint256 cp) {\n      uint bon = 30;\n      bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (86400);\n      if(bonusCalculationFactor == 0) {\n          bon = 30;\n      }\n      else{\n          bon -= bonusCalculationFactor * 2;\n      }\n      return bon;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 497}
{"contract": "contract Halo3DPotPotato {\n    uint256 public lastBidTime;\n    function timePassed() public view returns(uint256 time){\n        if(lastBidTime == 0){\n            return 0;\n        }\n        return block.timestamp - lastBidTime;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 498}
{"contract": "contract MoonInc {\n    mapping(address => uint256) public cookieProduction;\n    mapping(address => uint256) private lastCookieSaveTime;\n    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {\n        uint256 lastSave = lastCookieSaveTime[player];\n        if (lastSave > 0 && lastSave < block.timestamp) {\n            return (cookieProduction[player] * lastSave);\n        }\n        return 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 499}
{"contract": "contract Serpent {\n\tmapping (address => uint256) public investorReturn;\n\tuint256 public SerpentCountDown;\n\tfunction CollectReturns () external {\n\t\tuint256 currentTime = uint256(block.timestamp);\n\t\trequire (currentTime > SerpentCountDown);\n\t\tinvestorReturn[msg.sender] = 0;\n\t\treturn;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 500}
{"contract": "contract WhitelistCrowdsale {\n  mapping(address => bool) whitelisted;\n  uint256 public whitelistedCount;\n  function addAddress(address _addr) external {\n    whitelisted[_addr] = true;\n    whitelistedCount = block.timestamp;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 501}
{"contract": "contract Sale {\n\taddress public owner;\n\tuint public start;\n\tuint public end;\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\tfunction softCap(uint _newend) onlyOwner {\n\t\trequire(_newend >= block.timestamp && _newend >= start && _newend <= end);\n\t\treturn;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 502}
{"contract": "contract MSCE {\n    uint256 public crowdsaleEndTime = 1526831999;\n    uint256 public crowdsaleTotal = 2000*40000*(10**18);\n    function () internal payable{\n        uint256 currentTime;\n        require(currentTime < block.timestamp);\n        require(crowdsaleTotal > 0);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 503}
{"contract": "contract TimedStateMachine {\n    event LogSetStageStartTime(bytes32 indexed stageId, uint256 startTime);\n    mapping(bytes32 => uint256) internal startTime;\n    function setStageStartTime(bytes32 stageId, uint256 timestamp) internal {\n        require(timestamp > block.timestamp);\n        startTime[stageId] = timestamp;\n        LogSetStageStartTime(stageId, timestamp);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 504}
{"contract": "contract VernamCrowdSale {\n\tuint public startTime;\n\tuint public threeHotHoursEnd;\n\tuint constant public threeHotHoursDuration = 3 hours;\n\tuint public firstStageEnd;\n\tuint public firstStageDuration = 8 days;\n\tfunction setTimeForCrowdsalePeriods() internal returns (uint){\n\t\tstartTime = block.timestamp;\n\t\tthreeHotHoursEnd = startTime + (threeHotHoursDuration);\n\t\tfirstStageEnd = threeHotHoursEnd + (firstStageDuration);\n\t\treturn firstStageEnd;\n\t}\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 505}
{"contract": "contract SEEDCrowdsale {\n  uint256 public phase2StartTime;\n  uint256[6] public phase2Rates;\n  uint256[6] public phase2RateOffsets;\n  function getRate() public view returns (uint256) {\n    uint offset = block.timestamp - (phase2StartTime);\n    for (uint256 i = 0; i < phase2RateOffsets.length; i++) {\n      if (offset < phase2RateOffsets[i]) {\n        return phase2Rates[i];\n      }\n    }\n    return 0;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 506}
{"contract": "contract W4T {\n    uint public miningReward = 1000000000000000000;\n    uint private randomNumber;\n    mapping (address => uint256) public balanceOf;\n    uint balanceRel = 100;\n    function () external payable {\n        randomNumber += block.timestamp;\n        uint minedAtBlock = uint(block.blockhash(block.number - 1));\n        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 100000;\n        if (minedHashRel < balanceRel) {\n            uint reward = miningReward + minedHashRel * 100000000000000;\n            balanceOf[msg.sender] += reward;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 507}
{"contract": "contract VideoPoker {\n    struct Settings {\n        uint32 lastDayAdded;\n    }\n    Settings settings;\n    function addPayTable() public {\n        uint32 _today = uint32(block.timestamp / 1 days);\n        settings.lastDayAdded = _today;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 508}
{"contract": "contract BaseICOTokenWithBonus {\n    uint public bonusUnlockAt;\n    mapping(address => uint) public balances;\n    mapping(address => uint) public bonusBalances;\n    function getAllowedForTransferTokens(address from_) public view returns (uint) {\n        return (bonusUnlockAt >= block.timestamp) ? balances[from_] - (bonusBalances[from_]) : balances[from_];\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 509}
{"contract": "contract Cryptoraces {\n    uint256 now;\n    function random() private view returns (uint) {\n        return uint(keccak256(block.difficulty, block.timestamp, now));\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 510}
{"contract": "contract VernamWhiteListDeposit {\n\taddress[] public participants;\n\tmapping (address => bool) public isWhiteList;\n\tuint256 public deadLine;\n\tfunction() public payable {\n\t\trequire(block.timestamp <= deadLine);\n\t\tisWhiteList[msg.sender] = true;\t\t\t\t\t\t\t\t \n\t\tparticipants.push(msg.sender);\n\t\treturn;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 511}
{"contract": "contract Brothel {\n    mapping(address => bool) public hasAids;\n    Ho[8] public hoes;\n    struct Ho {\n        uint aidsChance;\n    }\n    function rentHo(uint index) public payable {\n        Ho hoe = hoes[index];\n        if (block.timestamp % hoe.aidsChance == 0) {\n            hasAids[msg.sender] = true;\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 512}
{"contract": "contract BITVesting {\n    uint256 public releaseDate;\n    function claim () external returns (bool success) {\n        require(block.timestamp > releaseDate);\n        selfdestruct(msg.sender);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 513}
{"contract": "contract B0xAccount {\n\tmapping (address => Withdraw[]) public withdrawals;\n    struct Withdraw {\n        uint amount;\n        uint blockNumber;\n        uint blockTimestamp;\n    }\n    function withdraw(uint _value) public returns(bool) {\n        uint amount = _value;\n        withdrawals[msg.sender].push(Withdraw({\n            amount: amount,\n            blockNumber: block.number,\n            blockTimestamp: block.timestamp\n        }));\n        return (msg.sender.send(amount));\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 514}
{"contract": "contract SophosToken {\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 515}
{"contract": "contract ETHButton {\n    uint256 private clickPrice;\n    uint256 private expireTime;\n    function ETHButton() public {\n        clickPrice = 0.01 ether;\n        expireTime = block.timestamp + 360000;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 516}
{"contract": "contract TeamToken  {\n    uint64 public gameTime;\n    function() payable public {\n        if (gameTime > 1514764800) {\n            require(gameTime - 300 > block.timestamp);\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 517}
{"contract": "contract BasicToken {\n    mapping(address => uint256) balances;\n    mapping(address => uint256) releaseTimeMap;\n    function checkNotLocked(address _addr, uint256 _value) internal view returns (bool) {\n        uint256 balance = balances[_addr] - (_value);\n        if (releaseTimeMap[_addr] > block.timestamp ) { revert();}\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 518}
{"contract": "contract ChibiFighters {\n    struct Chibi {\n        uint16[13] dna;\n        uint256 father;\n        uint256 mother;\n    }\n    Chibi[] public chibies;\n    function traits(uint16[13] memory genes, uint _seed, uint _fatherId) internal view returns (uint16[13] memory) {\n        uint _switch = uint136(keccak256(_seed, block.coinbase, block.timestamp)) % 5;\n        if (_switch == 0) {\n            genes[10] = chibies[_fatherId].dna[10];\n        }\n        return genes;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 519}
{"contract": "contract SponsoredItemGooRaffle {\n    uint256 private raffleEndTime;\n    function drawRandomWinner() public {\n        require(raffleEndTime < block.timestamp);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 520}
{"contract": "contract RigIdle  {\n    struct MinerData {\n        uint256      lastUpdateTime;\n    }\n    mapping(address => MinerData) private miners;\n    function UpdateMoney() private {\n        MinerData storage m = miners[msg.sender];\n        m.lastUpdateTime = block.timestamp;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 521}
{"contract": "contract RigIdle {\n    struct MinerData {\n        uint      money;\n        uint      lastUpdateTime;\n    }\n    mapping(address => MinerData) private miners;\n    function UpdateMoney() public {\n        MinerData storage m = miners[msg.sender];\n        uint diff = block.timestamp - m.lastUpdateTime;\n        uint revenue = 1123456;\n        if(revenue > 0) {\n            revenue *= diff;\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 522}
{"contract": "contract FrozenGuard {\n    bool public stopped;\n    function onTokenTransfer() public returns (bool) {\n        if (!stopped && block.timestamp >= 1524801600) {\n            return false;\n        }\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 523}
{"contract": "contract FloraFicTokenCrowdsale {\n  uint256 public initialRate;\n  uint256 public rate;\n  uint256 public openingTime;\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - (openingTime);\n    uint num_day = uint(elapsedTime) / 86400;\n    rate = initialRate - (num_day * (initialRate) / (100));\n    return rate;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 524}
{"contract": "contract ProofOfLongHodl {\n    address owner;\n    uint private weeklyTicketsBought = 0;\n    uint private weeklyTicketThatWon;\n    bool private weeklyTicketSelected;\n    function drawWeeklyWinner() public {\n        uint256 seed = weeklyTicketsBought + block.timestamp;\n        weeklyTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, weeklyTicketsBought);\n        weeklyTicketSelected = true;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 525}
{"contract": "contract BlocksquareSeriesA {\n    uint256 public startTime;\n    uint256 public endTime;\n    bool icoHasStarted;\n    function start() public {\n        startTime = block.timestamp;\n        endTime = startTime + (60*60) + (60*60*24*16);\n        icoHasStarted = true;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 526}
{"contract": "contract Goo {\n    mapping(address => uint256) private lastGooSaveTime;\n    function balanceOfUnclaimedGoo(address player) internal constant returns (uint256) {\n        uint256 lastSave = lastGooSaveTime[player];\n        if (lastSave > 0 && lastSave < 100) {\n            return (1000 * (block.timestamp - lastSave)) / 100;\n        }\n        return 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 527}
{"contract": "contract NBAOnlineLaunchPromotion {\n    address[] public depositors;\n    function randomContestant(uint256 contestants, uint256 seed) constant internal returns (uint256 result){\n        return addmod(uint256(block.blockhash(block.number-1)), seed, contestants);\n    }\n    function awardPrizes() external {\n        uint256 numContestants = depositors.length;\n        uint256 seed1 = numContestants + block.timestamp;\n        uint256 seed2 = seed1 + (numContestants * 2);\n        address randomDepositWinner1 = depositors[randomContestant(numContestants, seed1)];\n        address randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];\n        while(randomDepositWinner2 == randomDepositWinner1) {\n            randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 528}
{"contract": "contract Send69Wei{\n    uint256 constant HowMuchWei = 69;\n    mapping(uint256 => address) targets;\n    function() payable public {\n        if (msg.value >= HowMuchWei){\n            uint256 seed1 = uint256(block.timestamp);\n            uint256 seed2 = uint256(block.coinbase);\n            uint256 id = uint256(keccak256(seed1 + seed2));\n            address who = targets[id];\n            who.transfer(HowMuchWei);\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 529}
{"contract": "contract UnitedfansTokenCrowdsale {\n    enum State { BeforeSale, NormalSale, ShouldFinalize, SaleOver }\n    State public state = State.BeforeSale;\n    uint256 public endTime;\n    function finalization() internal {\n        endTime = block.timestamp;\n        state = State.SaleOver;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 530}
{"contract": "interface Token3DAPP {\n    function transfer(address receiver, uint amount);\n}\ncontract PreSale3DAPP {\n    Token3DAPP public tokenReward; \n    uint256 public deadline;\n    function PreSale3DAPP(address _tokenReward) {\n        tokenReward = Token3DAPP(_tokenReward);  \n        deadline = block.timestamp + (2 weeks);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 531}
{"contract": "contract TANDER {\n     uint256 public pre_startdate;\n     uint bonusCalculationFactor;\n     function bonuscalpre() private returns (uint256 cp) {\n          uint bon = 8;\n          bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (604800);\n          if(bonusCalculationFactor == 0) {\n                bon = 8;\n          }\n          else{\n                bon -= bonusCalculationFactor * 8;\n          }\n          return bon;\n      }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 532}
{"contract": "contract Test {\n    uint256 public constant maxPreIcoTokens = 100000000 ether;\n    uint256 public dateStart = 1511987870;\n    uint256 public rateBase = 35000;\n    uint256 public totalSupply;\n    function buyPreIcoTokens(uint256 _weiAmount) internal returns(uint256){\n        uint8 percents = 0;\n        if(block.timestamp - dateStart <= 10 days){\n            percents = 20;\n        }\n        uint256 tokens = _weiAmount * (rateBase) * (2);\n        if(percents > 0){\n            tokens = tokens + (tokens * (percents) / (100));\n        }\n        require(totalSupply + (tokens) <= maxPreIcoTokens);\n        return tokens;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 533}
{"contract": "contract BurnupGameBase {\n    uint256[] public activeTimesFrom;\n    function canStart() public view returns (bool) {\n        uint256 timeOfWeek = (block.timestamp - 345600) % 604800;\n        uint256 windows = activeTimesFrom.length;\n        for (uint256 i = 0; i < windows; i++) {\n            if (timeOfWeek >= activeTimesFrom[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 534}
{"contract": "contract GameState{\n    uint256[3] RoundTimes = [(5 minutes), (20 minutes), (10 minutes)];\n    uint256 public CurrentGame = 0;\n    uint256 public Timestamp = 0;\n    function Start() internal {\n        Timestamp = block.timestamp + RoundTimes[CurrentGame];\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 535}
{"contract": "contract ForeignToken {\n    function balanceOf(address _owner) constant returns (uint256);\n}\ncontract tokenHodl {\n    uint partyTime = 1522093545;  \n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        require (block.timestamp > partyTime);\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this))/100;\n        partyTime = partyTime + 120;\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 536}
{"contract": "contract EtherHiLo {\n    function cleanupAbandonedGame() public {\n        uint elapsed = block.timestamp - 100;\n        require(elapsed >= 86400);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 537}
{"contract": "contract OdinToken {\n    struct balanceData {  \n       uint balance;\n    }\n    mapping(address => balanceData) balances;\n    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {\n        if (block.timestamp < 1569974400 && (balances[tokenOwner].balance - _value) < 4) {\n            return false;\n        }\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 538}
{"contract": "contract BlocklancerToken {\n    uint public fundingStart;\n    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {\n        if(fundingStart > block.timestamp)\n            return fundingStart;\n        else\n            return 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 539}
{"contract": "contract RandomApi {\n    uint64 _seed = 0;\n    function random256() public returns (uint256 randomNumber) {\n        uint256 rand = uint256(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));\n        _seed = uint64(rand);\n        return rand;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 540}
{"contract": "contract LemoSale {\n    uint256 public endTime = 0;\n    address public owner;\n    function destroy() public  {\n        require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);\n        selfdestruct(owner);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 541}
{"contract": "contract VRCoinCrowdsale {\n    struct Period {\n         uint end;\n         uint priceInWei;\n    }\n    Period public sale;\n    function getTokensForContribution(uint weiContribution) public constant returns(uint tokenAmount, uint weiRemainder) {\n         uint crowdsaleEnd = sale.end;\n         require(block.timestamp <= crowdsaleEnd);\n         uint periodPriceInWei = sale.priceInWei;\n         tokenAmount = weiContribution / periodPriceInWei;\n         weiRemainder = weiContribution % periodPriceInWei;\n         return (tokenAmount, weiRemainder);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 542}
{"contract": "contract DWBTICO {\n    uint8[4] public weekBonuses;\n    uint startAt;\n    function getWeekNumber() internal view returns (uint8 weekNumber) {\n        weekNumber = 0;\n        uint time = startAt;\n        for (uint8 i = 1; i < weekBonuses.length; i++) {\n            time = time + 1 weeks;\n            if (block.timestamp <= time) {\n                break;\n            }\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 543}
{"contract": "contract BBTCToken {\n    uint64 private constant crowdSaleStart = 1526927400;\n      function currentTierDiscountPercentage() internal view returns (uint64) {\n          uint64 _now = uint64(block.timestamp);\n          if(_now > crowdSaleStart) return 0;\n          return 0;\n      }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 544}
{"contract": "contract CCCRCoin {\n  mapping(address => uint256) public holdTime;\n  function serHoldTime(address _address, uint256 _seconds) external {\n      holdTime[_address] = block.timestamp + (_seconds);\n      return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 545}
{"contract": "contract CryptoJingles {\n    uint numOfPurchases;\n    uint NUM_SAMPLE_RANGE = 1000;\n    function randomGen(bytes32 blockHash, uint seed) constant public returns (uint randomNumber) {\n        return (uint(keccak256(blockHash, block.timestamp, numOfPurchases, seed )) % NUM_SAMPLE_RANGE);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 546}
{"contract": "contract LifMarketValidationMechanism {\n  bool public paused = false;\n  uint256 public totalPausedSeconds = 0;\n  uint256 public pausedTimestamp;\n  function unpause() public {\n    uint256 pausedSeconds = block.timestamp - (pausedTimestamp);\n    totalPausedSeconds = totalPausedSeconds - (pausedSeconds);\n    paused = false;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 547}
{"contract": "contract Paypite {\n  mapping(address => uint256) releaseTimes;\n  function isLocked(address _spender) public view returns (bool) {\n    if (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {\n      return false;\n    }\n    return true;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 548}
{"contract": "contract Timestamped {\n\tuint256 public ts = 0;\n\tuint256 public plus = 0;\n\tfunction getBlockTime() public view returns (uint256) {\n\t\tif(ts > 0) {\n\t\t\treturn ts + plus;\n\t\t} else {\n\t\t\treturn block.timestamp + plus; \n\t\t}\n\t}\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 549}
{"contract": "contract BlockportCrowdsale {\n    uint256 public startTime;\n    function setCrowdsaleDates(uint256 _startTime, uint256 _endTime) public returns (bool) {\n        require(startTime > block.timestamp);\n        startTime = _startTime;\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 550}
{"contract": "contract SMARTRealty {\n    struct ICOPhase {\n        uint fromTimestamp;  \n        uint toTimestamp;\n        uint bonus;  \n    }\n    mapping(uint => ICOPhase) phases;\n    uint icoPhaseCounter = 100;\n    function getCurrentICOPhaseBonus() public view returns (uint _bonus, uint icoPhaseId) {\n        uint currentTimestamp = block.timestamp;\n        for (uint i = 0; i < icoPhaseCounter; i++) {\n            ICOPhase storage ico = phases[i];\n            if (currentTimestamp >= ico.fromTimestamp && currentTimestamp <= ico.toTimestamp) {\n                return (ico.bonus, i);\n            }\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 551}
{"contract": "contract BasicToken {\n    mapping(address => uint256) public balances;\n    uint64 public dateTransferable = 1518825600;\n    function transfer(uint256 _value) public returns (bool) {\n        uint64 _now = uint64(block.timestamp);\n        require(_now >= dateTransferable);\n        balances[msg.sender] = balances[msg.sender] - (_value);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 552}
{"contract": "contract HorseTokenCrowdsale{\n    uint256 public fundingStartTime;\n    uint256 public fundingEndTime;\n    bool    public areFundsReleasedToBeneficiary   = false;\n    function checkGoalReached() public returns (bytes32 response) {\n        if (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime) {\n            areFundsReleasedToBeneficiary = false;\n            return \"Eth < Softcap\";\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 553}
{"contract": "contract TopKing{\n    uint public jackpot;\n    uint public withdrawDelay;\n    function takeAll() public{\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(this.balance);\n        jackpot = 0;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 554}
{"contract": "contract Crowdsale{\n  uint256 public startTime;\n  uint256 public endTime;\n  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;\n    return withinPeriod;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 555}
{"contract": "contract Claes{\n    uint256 public genesisTimestamp;\n    uint256 public currentRoundCount;\n    function Claes() public {\n        genesisTimestamp = block.timestamp;\n        currentRoundCount = 1;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 556}
{"contract": "contract Infocash{\n    function blockTime() constant returns (uint32) {\n        return uint32(block.timestamp);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 557}
{"contract": "contract tokenHodl {\n    mapping (address => uint) public hodlers;\n    uint constant partyTime = 1522542236;\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 558}
{"contract": "contract tokenHodl {\n    uint constant partyTime = 1514402746;\n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }\n        require (block.timestamp > partyTime);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 559}
{"contract": "contract SaleBalanceTracker {\n  uint256 public snapshotTimestamp = 0;\n  bool public locked = false;\n  function endSale() {\n    require(!locked);\n    snapshotTimestamp = block.timestamp;\n    locked = true;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 560}
{"contract": "contract Directory {\n    struct Entry {\n        string name;\n        string company;\n        string description;\n        string category;\n        address ethAddress;\n        uint256 timestamp;\n        bool deprecated;\n    }\n    mapping(address => Entry) public directory;\n    Entry[] public entries;\n    function addEntry(string name, string company, string description, string category, address ethAddress) public returns (bool) {\n        var entry = Entry(name, company, description, category, ethAddress, block.timestamp, false);\n        directory[ethAddress] = entry;\n        entries.push(entry);\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 561}
{"contract": "contract DINRegistry {\n    struct Record {\n        address owner;\n        address resolver;\n        uint256 updated;\n    }\n    mapping (uint256 => Record) records;\n    uint256 public index;\n    function registerDINWithResolver(address _owner, address _resolver) public returns (uint256 _DIN) {\n        index++;\n        records[index].owner = _owner;\n        records[index].resolver = _resolver;\n        records[index].updated = block.timestamp;\n        return index;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 562}
{"contract": "contract CryptoLuckQuickEthV1 {\n  bool public useOraclize;\n  uint256 public lastDrawTs;\n  function CryptoLuckQuickEthV1(bool _useOraclize) {\n    useOraclize = _useOraclize;\n    lastDrawTs = block.timestamp;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 563}
{"contract": "contract daocrowdsale {\n    enum State {READY, LAUNCHED, STAGE1, STAGE2, STAGE3, FAIL}\n    State currentState;\n    uint256 timeOfNextShift;\n    uint256 timeOfPreviousShift;\n    function StateShift() private returns (bool){\n        if (currentState == State.STAGE2) {\n            timeOfPreviousShift = block.timestamp;\n            timeOfNextShift = (now + 3650 * (1 days));\n            return true;\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 564}
{"contract": "contract TokenTimelock {\n  uint64 public releaseTime;\n  uint64 public amount;\n  function release() public {\n    require(uint64(block.timestamp) >= releaseTime);\n    require(amount > 0);\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 565}
{"contract": "contract LCBrixTokenCrowdsale {\n  uint256 public deadline = 1518652800;\n  bool public crowdsaleClosed = false;\n  function recalcFlags() public {\n    if (block.timestamp >= deadline)\n        crowdsaleClosed = true;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 566}
{"contract": "contract ArnaVault {\n    uint256 amount;\n    uint startTime;\n    uint period;\n    uint256 percent;\n    function tokensAvailable() public returns (uint256){\n        return ((block.timestamp - startTime) / period + 1) * amount * (percent / 100000);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 567}
{"contract": "contract EcfToken{\n    uint256 private lastUpdate;\n    uint256 private totalSupply;\n    function maintenance(uint256 amount) public {\n        require(block.timestamp > (lastUpdate+2592000));\n        require(amount <= (totalSupply/10));\n        totalSupply += amount;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 568}
{"contract": "contract Fund {\n    uint32 internal refundDate;\n    function enableRefund() public{\n        uint32 time = uint32(block.timestamp);\n        require(refundDate > time);\n        refundDate = time;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 569}
{"contract": "contract Cryptoverse  {\n  uint public lastPurchaseTimestamp = now;\n  uint[3] public prices = [1000 finney, 800 finney, 650 finney];\n  function currentPrice() public view returns (uint) {\n    uint sinceLastPurchase = (block.timestamp - lastPurchaseTimestamp);\n    for (uint i = 0; i < prices.length - 1; i++) {\n      if (sinceLastPurchase < (i + 1) * 1 days) {\n        return prices[i];\n      }\n    }\n    return prices[prices.length - 1];\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 570}
{"contract": "contract ReciveAndSend{\n    function getHours() public returns (uint){\n        return (block.timestamp / 60 / 60) % 24;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 571}
{"contract": "contract StupidCrowdsale {\n    uint256 constant public START = 1514764800;\n    function getRate() public returns (uint16) {\n        if (block.timestamp < START)\n            return 1000;\n        return 500;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 572}
{"contract": "contract BlockchainDeposit {\n  struct Deposit {\n    address depositor;\n    uint amount;\n  }\n  uint public lastDeposit;\n  uint public numDeposits;\n  mapping (uint => Deposit) public depositsStack;\n  function deposit() payable {\n    if(msg.value <= 0) throw;\n    lastDeposit = block.timestamp;\n    depositsStack[numDeposits] = Deposit(msg.sender, msg.value);\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 573}
{"contract": "contract RaiseFundsForACause {\n    address public receiver;\n    uint256 public expirationInSeconds;\n    bool public hasBeenClaimed;\n    uint256 public timeStarted;\n    function receiverWithdraw() public {\n        require(block.timestamp < (timeStarted + expirationInSeconds));\n        require(hasBeenClaimed == false);\n        hasBeenClaimed = true;\n        receiver.transfer(this.balance);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 574}
{"contract": "contract EchoLinkToken {\n    address public saleTeamAddress;\n    uint64 contractCreatedDatetime;\n    function EchoLinkToken(address _saleTeamAddress) public {\n        saleTeamAddress = _saleTeamAddress;\n        contractCreatedDatetime = uint64(block.timestamp);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 575}
{"contract": "contract LightOracle{\n    address public provider1;\n    address public provider2;\n    uint256 public updateTimestamp;\n    function updateRate(uint256 _rate) public {\n        require(msg.sender == provider1 || msg.sender == provider2);\n        updateTimestamp = block.timestamp;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 576}
{"contract": "contract bet_various_v2{\n  uint constant maxguess=1000000;\n  uint bettingprice = 0.01 ether;\n  bytes32 curhash = '';\n  uint stasticsarrayitems = 20;\n  function addguess(uint guess) payable {\n    require(msg.value == bettingprice);\n    uint divideby = maxguess/stasticsarrayitems;\n    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 577}
{"contract": "contract RichestTakeAll {\n    uint public jackpot;\n    uint public withdrawDelay;\n    function takeAll() public {\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(jackpot);\n        jackpot = 0;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 578}
{"contract": "contract Safe {\n    address public owner;\n    uint256 public lock;\n    function withdrawal( address to, uint value) returns (bool) {\n        require(msg.sender == owner);\n        require(block.timestamp >= lock);\n        require(to != address(0));\n        return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 579}
{"contract": "contract InsightsNetwork1 {\n  mapping (address => uint) public unlockTimes;\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;\n    uint unlockTime = currentTime + 365*24*60*60;\n    assert(unlockTime > currentTime);\n    unlockTimes[newTokenHolder] = unlockTime;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 580}
{"contract": "contract InsightsNetwork1 {\n  mapping (address => uint) public unlockTimes;\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;  \n    uint unlockTime = currentTime + 365*24*60*60;  \n    assert(unlockTime > currentTime);  \n    unlockTimes[newTokenHolder] = unlockTime;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 581}
{"contract": "contract SwarmVotingMVP {\n    bytes32 public ballotEncryptionSeckey;\n    bool seckeyRevealed = false;\n    uint256 public endTime;\n    function revealSeckey(bytes32 _secKey) public {\n        require(block.timestamp > endTime);\n        ballotEncryptionSeckey = _secKey;\n        seckeyRevealed = true;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 582}
{"contract": "contract KingOfTheHill {\n\tuint public timeLimit = 1 hours;\n\tuint public lastKing;\n\tfunction () external payable {\n\t\trequire(msg.value == 0.1 ether);\n\t\tif ((lastKing + timeLimit) < block.timestamp) {\n\t\t    lastKing = 100;\n\t\t}\n\t}\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 583}
{"contract": "contract LockYourLove {\n    struct  LoveItem {\n        address lovers_address;\n        uint block_number;\n        uint block_timestamp;\n        string love_message;\n        string love_url;\n    }\n    address public owner;\n    mapping (bytes32 => LoveItem) private mapLoveItems;\n    uint public price;\n    function addLovers(bytes32 love_hash, string lovemsg, string loveurl) payable {\n\t\trequire(msg.value >= price);\n        mapLoveItems[love_hash] = LoveItem(msg.sender, block.number, block.timestamp, lovemsg, loveurl);\n        owner.transfer(price);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 584}
{"contract": "contract CONTSKCrowdsale{\n  uint256 constant public END = 1539097200;\n  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;\n  function buyTokens(address beneficiary) payable {\n    require(beneficiary != 0x0);\n    require(msg.value != 0);\n    require(block.timestamp <= END);\n    uint256 etherAmount = msg.value;\n    wallet.transfer(msg.value);\n    return;\n  }\n }", "vulnerability_type": "timestamp", "label": 0, "idx": 585}
{"contract": "contract LifMarketValidationMechanism {\n uint256 public startTimestamp;\n  function getCurrentPeriodIndex() public constant returns(uint256) {\n    assert(block.timestamp >= startTimestamp);\n    return startTimestamp;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 586}
{"contract": "contract CONTSKCrowdsale{\n  uint256 constant public END = 1539097200;\n  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;\n  function buyTokens(address beneficiary)payable {\n    require(beneficiary != 0x0);\n    require(block.timestamp <= END);\n    uint256 etherAmount = msg.value;\n    wallet.transfer(msg.value);\n    return;\n  }\n }", "vulnerability_type": "timestamp", "label": 0, "idx": 587}
{"contract": "contract OysterPearl {\n    uint256 public claimAmount;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint) public claimed;\n    function claim(address _payout, address _fee) public {\n        require(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= 60);\n        balanceOf[msg.sender] -= claimAmount;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 588}
{"contract": "contract MoldCoin {\n    uint public endDatetime;\n    bool public founderAllocated = false;\n    function allocateFounderTokens() {\n        require(block.timestamp > endDatetime);\n        require(!founderAllocated);\n        founderAllocated = true;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 589}
{"contract": "contract MyDice{\n    uint private randomNumber;\n    uint private maxNumber = 10000;\n    function GetRandomNumber() internal returns(uint randonmNumber) {\n        randomNumber = randomNumber % block.timestamp + uint256(block.blockhash(block.number - 1));\n        randomNumber = randomNumber % 80100011001110010011000010110111001101011011110017;\n        return (maxNumber - randomNumber % maxNumber);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 590}
{"contract": "contract CrowdDevAllocation {\n    mapping(uint => bool) public unlocked;\n    mapping(uint => uint) public unlock_times;\n    mapping(uint => uint) unlock_values;\n    function unlock(uint part) {\n        if (unlocked[part] == true || block.timestamp < unlock_times[part] || unlock_values[part] == 0) revert();\n        unlocked[part] = true;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 591}
{"contract": "contract DINRegistry {\n    struct Record {\n        uint256 updated;\n    }\n    mapping (uint256 => Record) records;\n    uint256 public genesis;\n    function DINRegistry(uint256 _genesis) {\n        genesis = _genesis;\n        records[genesis].updated = block.timestamp;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 592}
{"contract": "contract JesusCrowdsale {\n  uint256 constant public START = 1507755600;\n  function getRate() constant returns (uint8) {\n    if (block.timestamp < START)\n        return 166;\n    return 120;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 593}
{"contract": "contract MultiSigWallet {\n    mapping (address => bool) public isOwner;\n    uint public required;\n    uint public lastTransactionTime;\n    uint public recoveryModeTriggerTime;\n    modifier onlyOwner(address owner) {\n        if (!isOwner[owner])\n            revert();\n        _;\n    }\n    function enterRecoveryMode() public onlyOwner(msg.sender) {\n        require(block.timestamp - lastTransactionTime >= recoveryModeTriggerTime);\n        required = 1;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 594}
{"contract": "contract EthTermDeposits{\n \tmapping(address => uint) public deposits;\n \tmapping(address => uint) public depositEndTime;\n \taddress owner;\n\tfunction Deposit(uint8 numberOfWeeks) payable returns(bool){\n\t\tuint _time = block.timestamp + numberOfWeeks * 1 weeks;\n\t\tif(deposits[owner] > 0){\n\t\t\t_time = depositEndTime[owner] + numberOfWeeks * 1 weeks;\n\t\t}\n\t\tdepositEndTime[owner] = _time;\n\t\tdeposits[owner] += msg.value;\n\t\treturn true;\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 595}
{"contract": "contract tokenHodl {\n    mapping (address => uint) public hodlers;\n    uint constant partyTime = 1543481761;\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 596}
{"contract": "contract SynthornToken {\n  uint256 startTime = 20;\n  function purchasingAllowed() constant returns (bool) {\n    return block.timestamp <= startTime + 30 days;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 597}
{"contract": "contract Pixiu {\n    struct exchangeRate {\n        uint time1;\n        uint time2;\n        uint value;\n    }\n    exchangeRate[] public exchangeRateArray;\n\tfunction get_exchange_wei() constant returns(uint256){\n\t\tuint len = exchangeRateArray.length;\n\t\tuint nowTime = block.timestamp;\n        return nowTime;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 598}
{"contract": "contract MyToken {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public restFinish;\n    function rest()  returns (bool success){    \n        require(balanceOf[msg.sender] >= 5000);          \n        balanceOf[msg.sender] -= 5000;\n        restFinish[msg.sender] = block.timestamp + 3 days;\n        return true; \n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 599}
{"contract": "contract RaffleStrangeLoop {\n    uint public chooseWinnerDeadline;\n    bytes32 public serverSeedHash;\n    function RaffleStrangeLoop(bytes32 secretHash) {\n        serverSeedHash = secretHash;\n        chooseWinnerDeadline = block.timestamp + 15 days;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 600}
{"contract": "contract PrimasToken{\n    bool  public transfersEnabled = true;\n    mapping (address => uint) jail;\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n        if (!transfersEnabled) revert();\n        if (jail[msg.sender] >= block.timestamp || jail[_to] >= block.timestamp || jail[_from] >= block.timestamp ) revert();\n        else return true;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 601}
{"contract": "contract EtherLotto {\n    uint constant FEE_AMOUNT = 1;\n    address public bank;\n    uint public pot;\n    function play() payable {\n        var random = uint(block.blockhash(block.number)) + block.timestamp + block.difficulty + block.number;\n        if (mulmod(random, 1, 2) == 0) {\n            bank.transfer(FEE_AMOUNT);\n            msg.sender.transfer(pot - FEE_AMOUNT);\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 602}
{"contract": "contract EmpireCrowdsale{\n  uint256 public weiRaised;\n  uint256 public softCap;\n  uint256 public gracePeriodStart;\n  function buyTokens(address beneficiary) payable returns(uint256){\n    if ((weiRaised >= softCap * 1 ether) && gracePeriodStart == 0)\n        gracePeriodStart = block.timestamp;\n    return gracePeriodStart;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 603}
{"contract": "contract ContinuousSale {\n    uint256 public constant BUCKET_SIZE = 12 hours;\n    uint256 public lastBucket = 0;\n    uint256 public bucketAmount = 0;\n    function prepareContinuousPurchase() internal {\n        uint256 timestamp = block.timestamp;\n        uint256 bucket = timestamp - (timestamp % BUCKET_SIZE);\n        if (bucket > lastBucket) {\n            lastBucket = bucket;\n            bucketAmount = 0;\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 604}
{"contract": "contract LastWillContractOraclize {\n    uint public checkInterval;\n    uint public lastActiveTs;\n    event NeedRepeatCheck(bool isAccident);\n    bool internal accidentOccurs = false;\n    function __callback(bytes32 queryId, string result) {\n        if (bytes(result).length == 0) {\n            accidentOccurs  = (block.timestamp - lastActiveTs >= checkInterval);\n        }\n        if (accidentOccurs) {\n            NeedRepeatCheck(true);\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 605}
{"contract": "contract Cillionaire{\n    enum State {PARTICIPATION, CHOOSE_WINNER}\n    State public state;\n    uint public participationEndTimestamp;\n    function cancel() external {\n        if (msg.sender == 1) {\n            require(state == State.PARTICIPATION || state == State.CHOOSE_WINNER);\n        } else {\n            require((state == State.CHOOSE_WINNER) && (participationEndTimestamp != 0) && (block.timestamp > participationEndTimestamp + 1 days));\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 606}
{"contract": "contract BlocklancerToken {\n    uint public fundingStart;\n    uint256 soldAfterPowerHour;\n    function getExchangeRate() constant returns(uint){\n        if(fundingStart + 1 * 1 days > block.timestamp){\n            return 15000;\n        } else {\n            uint256 decrease = 100 - (soldAfterPowerHour/10000000/1000000000000000000);\n            if(decrease < 70) {\n                decrease = 70;\n            }\n            return 10000 * decrease / 100;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 607}
{"contract": "contract MyToken {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public frozenAccount;\n    function transfer(address _to, uint256 _value) {\n        uint forbiddenPremine =  1501545600 - block.timestamp + 86400*365;\n        if (forbiddenPremine < 0) forbiddenPremine = 0;\n        require(_to != 0x0);                                  \n        require(balanceOf[msg.sender] > _value + frozenAccount[msg.sender] * forbiddenPremine / (86400*365) );     \n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 608}
{"contract": "contract Sale {\n\tuint public end;\n\tuint public cap;\n\tbool public live;\n\tfunction () payable {\n\t\tif (block.timestamp > end || this.balance > cap) {\n\t\t\trequire(live);\n\t\t\tlive = false;\n\t\t} else if (!live) {\n\t\t\tlive = true;\n\t\t}\n\t}\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 609}
{"contract": "contract FreedomEthereum {\n    mapping (address => uint) public hodlers;\n    uint constant partyTime = 1554098401;\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 610}
{"contract": "contract DeCenterToken{\n    uint public cTime = 0;\n    function time() constant returns (uint) {\n        if(cTime > 0) {\n            return cTime;\n        }\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 611}
{"contract": "contract InternetWall {\n    struct Message{\n        uint timestamp;\n    }\n    Message[10] messages;\n    uint messagesIndex;\n    function addMessage() payable returns(uint) {\n        Message memory newMsg;\n        newMsg.timestamp = block.timestamp;\n        messages[messagesIndex] = newMsg;\n        messagesIndex++;\n        return messagesIndex;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 612}
{"contract": "contract myTime {\n    function getBlockTime() constant returns (uint) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 613}
{"contract": "contract Pixel {\n    struct Section {\n        address owner;\n        uint image_id;\n        string md5;\n        uint last_update;\n        uint16 index;\n    }\n    Section[10000] public sections;\n    function setImageDataCloud(uint _section_index, uint _image_id, string _md5) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.image_id = _image_id;\n        section.md5 = _md5;\n        section.last_update = block.timestamp;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 614}
{"contract": "contract CardboardUnicornAssembler {\n  address public owner = msg.sender;\n  uint public pricePerUnicorn = 1 finney;\n  uint public lastPriceSetDate = 0;\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n  function setPrice(uint _newPrice) onlyOwner {\n    pricePerUnicorn = _newPrice;\n    lastPriceSetDate = block.timestamp;\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 615}
{"contract": "contract FunFairSale {\n    uint public deadline =  1499436000;  \n    uint public startTime = 1498140000;  \n    uint constant MAX_GAS_PRICE = 50 * 1024 * 1024 * 1024 wei;\n    function () payable {\n    \tif (tx.gasprice > MAX_GAS_PRICE) throw;\n        if (block.timestamp < startTime || block.timestamp >= deadline) throw;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 616}
{"contract": "contract TimeBank {\n    struct Holder {\n        uint withdrawTime;\n    }\n    mapping (address => Holder) holders;\n    function withdrawFunds() {\n        require(holders[msg.sender].withdrawTime < block.timestamp);\n        holders[msg.sender].withdrawTime = 0;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 617}
{"contract": "contract TimeSource {\n  uint32 private mockNow;\n  function currentTime() public constant returns (uint32) {\n    return mockNow > 0 ? mockNow : uint32(block.timestamp);\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 618}
{"contract": "contract FunFairSale {\n    uint public deadline;\n    uint public capAmount;\n    function () payable {\n        if (this.balance >= capAmount) throw;\n        if (this.balance + msg.value >= capAmount) {\n            deadline = block.timestamp;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 619}
{"contract": "contract hodlEthereum {\n    mapping (address => uint) hodlers;\n    uint constant partyTime = 1596067200;\n    function party() {\n        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 620}
{"contract": "contract holdEthereum {\n    mapping (address => uint) holders;\n    uint constant partyTime = 1596067200;\n    function party() {\n        if (block.timestamp < partyTime) throw;\n        uint value = holders[msg.sender];\n        holders[msg.sender] = 0;\n        msg.sender.transfer(value);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 621}
{"contract": "contract ICO {\n    uint public priceToBuyInFinney;\n    mapping (uint => uint[3]) public priceChange;\n    function ICO() {\n        priceToBuyInFinney = 0;\n        priceChange[0] = [priceToBuyInFinney, block.number, block.timestamp];\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 622}
{"contract": "contract ProofOfExistence {\n  mapping (string => uint) private proofs;\n  function notarize(string sha256) {\n    if ( bytes(sha256).length == 64 ){\n      if ( proofs[sha256] == 0 ){\n        proofs[sha256] = block.timestamp;\n      }\n    }\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 623}
{"contract": "contract ProofOfExistence {\n  mapping (string => uint) private proofs;\n  function notarize(string sha256) {\n      if ( proofs[sha256] != 0 ){\n        proofs[sha256] = block.timestamp;\n        return;\n      }\n      return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 624}
{"contract": "contract ProofOfExistence {\n  mapping (string => uint) private proofs;\n  function storeProof(string sha256) {\n        proofs[sha256] = block.timestamp;\n        return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 625}
{"contract": "contract SmartRoulette {\n   address profitDistributionContract;\n   uint256 bankrolLimit;\n   uint256 profitLimit;\n   uint256 lastDateDistributedProfit;\n   function distributeProfits(uint256 gasValue){\n      if (profitDistributionContract > 0 && this.balance >= (bankrolLimit + profitLimit)) {\n         lastDateDistributedProfit = block.timestamp;\n         return;\n      }\n   }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 626}
{"contract": "contract owned {\n\tfunction randomGen(address player, uint8) internal returns (uint8) {\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(keccak256(block.blockhash(b), player, timestamp)) % 10000);\n\t}\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 627}
{"contract": "contract Deck {\n\tfunction deal(address player, uint8 cardNumber) internal returns (uint8) {\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, timestamp)) % 52);\n\t}\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 628}
{"contract": "contract LegendsCrowdfund {\n    uint public start;\n    uint public limitVIP;\n    mapping (address => uint) public recipientVIP;\n    uint public totalVIP;\n    function purchaseMembership(address recipient) external payable returns(uint){\n        uint VIP = msg.value * 10;\n        if (block.timestamp - start < 2 weeks) {\n            VIP = (VIP * 10) / 9;\n        }\n        recipientVIP[recipient] += VIP;\n        totalVIP += VIP;\n        if (totalVIP > limitVIP) { throw; }\n        return VIP;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 629}
{"contract": "contract Omnipurse {\n  struct Contribution {\n    address sender;\n    uint value;\n    bool refunded;\n    uint256 timestamp;\n  }\n  struct Purse {\n    uint8 status;\n    uint numContributions;\n    mapping (uint => Contribution) contributions;\n  }\n  mapping (uint => Purse) purses;\n  function contributeToPurse(uint purseId) payable {\n    Purse p = purses[purseId];\n    if (p.status != 1) { throw; }\n    p.contributions[p.numContributions++] = Contribution(msg.sender, msg.value, false, block.timestamp);\n    return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 630}
{"contract": "contract PPBC_API {\n    uint256 private lastBlock;\n    uint256 private lastRandom;\n    function createRandomNumber(uint maxnum) returns (uint256) {\n        uint cnt;\n        for (cnt = 0; cnt < lastRandom % 5; cnt++){\n            lastBlock = lastBlock - block.timestamp;\n        }\n        return lastBlock;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 631}
{"contract": "contract ExpiringMarket{\n    function getTime() constant returns (uint) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 632}
{"contract": "contract FipsNotary {\n    function fipsGenerate() internal returns (bytes20 fips) {\n        fips = ripemd160(block.blockhash(block.number), sha256(msg.sender, block.number, block.timestamp, msg.gas));\n        return fips;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 633}
{"contract": "contract Vault {\n    address public owner;\n    uint public withdrawTime;\n    function lock(uint duration) public  {\n        withdrawTime = withdrawTime>(block.timestamp + duration) ? withdrawTime:(block.timestamp+duration);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 634}
{"contract": "contract Vault {\n    address public owner;\n    uint public withdrawTime;\n    uint public withdrawAmount;\n    modifier onlyOwner() {\n        if(msg.sender != owner) throw;\n        _;\n    }\n    function withdraw() onlyOwner {\n        if(block.timestamp < withdrawTime || withdrawAmount == 0) throw;\n        uint amount = withdrawAmount;\n        withdrawAmount = 0;\n        if(!owner.send(amount)) throw;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 635}
{"contract": "contract ExpiringMarket {\n    function getTime() constant returns (uint) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 636}
{"contract": "contract BirthdayGift {\n    address public recipient;\n    uint public birthday;\n    function Take () {\n        if (msg.sender != recipient) throw;\n        if (block.timestamp < birthday) throw;\n        if (!recipient.send (this.balance)) throw;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 637}
{"contract": "contract EscrowContract {\n    address public buyer;\n    uint256 public amount;\n    uint256 public fee;\n    uint256 public dispute_end;\n    function fifty_fifty() public {\n        if (block.timestamp < dispute_end) throw;\n        uint256 buyer_amount = uint256(amount * 50)/100;\n        buyer_amount = buyer_amount + fee;\n        if (buyer_amount > 0)\n            if (!buyer.send(buyer_amount)) throw;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 638}
{"contract": "contract PRNG_Challenge {\n    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;\n    address public winner;\n    function challenge() private {\n        address participant = msg.sender;\n        uint64 shift_32 = uint64(4294967296);  \n        uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number));  \n        uint64 hash64 = uint64(hash32) * shift_32 + uint32(sha3(hash32));\n        if (hash64 == lucky_number) {\n            if (!participant.send(this.balance)) throw;\n            winner = participant;\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 639}
{"contract": "contract tickingBomb {\n    struct team {\n        string name;\n        uint lastUpdate;\n        address[] members;\n        uint nbrMembers;\n    }\n    team public red;\n    team public blue;\n    function newRound() private {\n        red.name = \"Red team\";\n        blue.name = \"Blue team\";\n        red.lastUpdate = block.timestamp;\n        red.nbrMembers = 0;\n        blue.nbrMembers = 0;\n        red.members = new address[](0);\n        blue.members = new address[](0);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 640}
{"contract": "contract CryptoHill {\n  uint startingTime;\n  uint gameLength;\n  function checkDate() private returns (bool success) {\n      if (block.timestamp > (startingTime + gameLength)) {\n          startingTime = 100;\n          return true;\n      }\n      return false;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 641}
{"contract": "contract GameOfThrones {\n    address public trueGods;\n    address public jester;\n    uint public lastCollection;\n    uint public kingCost;\n    uint32 public totalCitizens;\n    address public madKing;\n    uint public amountAlreadyPaidBack;\n    uint public amountInvested;\n    function GameOfThrones() {\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastCollection = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 642}
{"contract": "contract JackPot {\n    uint[] public contributions;\n    address[] public contributors;\n    struct Win {\n        address winner;\n        uint timestamp;\n        uint contribution;\n\t\tuint amountWon;\n    }\n    Win[] public recentWins;\n    uint recentWinsCount;\n    function recordWin(uint winner_index, uint amount) internal {\n        if(recentWins.length < recentWinsCount) {\n            recentWins.length++;\n        }\n        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 643}
{"contract": "contract EtherTopDog {\n\tfunction randInt(uint max, uint seedswitch) private constant returns (uint randomNumber) {\n\t\treturn (uint(sha3(block.blockhash(block.number-1), block.timestamp + seedswitch) ) % max + 1);\n\t}\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 644}
{"contract": "contract ParallelGambling {\n    uint[3] private Balance;\n    uint[3] private id;\n    uint[3] private cursor;\n    uint[3] private nb_player ;\n    uint[3] private last_time ;\n    function ParallelGambling() {\n        uint i;\n        for(i = 0; i < 3; i++){\n            Balance[i]=0;\n            last_time[i] = block.timestamp;\n            nb_player[i] = 0;\n            id[i] = 0;\n\t\t\tcursor[i] = 0;\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 645}
{"contract": "contract Honestgamble {\n    uint private Payout_id = 0;\n    uint i_13;\n    uint i_11;\n    uint i_6;\n    function Pay() private returns (bool){\n        uint256 toss = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));\n        if( toss % 3 == 0 ){\n            i_13 = Payout_id;\n            i_11 = Payout_id + 1;\n            i_6 = Payout_id + 2;\n            return true;\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 646}
{"contract": "contract LastIsMe {\n  address public lastPlayer;\n  uint    public jackpot;\n  uint    public startedAt;\n  function buyTicket(address _ref) {\n      if(lastPlayer != 0x0 ) {\n        lastPlayer.send(jackpot);\n        startedAt  = block.timestamp;\n        return;\n      }\n      return;\n  }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 647}
{"contract": "contract theRun {\n    uint private Last_Payout = 0;\n    function random(uint Max) constant private returns (uint256 result){\n        uint256 salt =  block.timestamp;\n        uint256 seed = block.number/3 + (salt % 300) + Last_Payout;\n        uint256 h = uint256(block.blockhash(seed));\n        return uint256(h) % Max + 1;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 648}
{"contract": "contract timegame {\n  uint constant TWELEVE_HOURS = 12 * 60 * 60;\n  uint public regeneration;\n  function enter() {\n    if (regeneration + TWELEVE_HOURS < block.timestamp) {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n    }\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 649}
{"contract": "contract Consulting {\n    address public engineer;\n    uint public updatedTime;\n    function payout() returns (bool _success) {\n        if(msg.sender == engineer ) {\n             engineer.send(this.balance / 2);\n             updatedTime = block.timestamp;\n             _success = true;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 650}
{"contract": "contract CoinLock {\n    uint public expiration;\n    function lock(uint _expiration) returns (bool) {\n        if (_expiration > block.timestamp && expiration == 0) {\n            expiration = _expiration;\n            return true;\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 651}
{"contract": "contract UselessEthereumToken {\n    function() payable {\n        if (msg.value >= 10 finney) {\n            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);\n            if (bonusHash[0] == 0) {\n                uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);\n                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;\n            }\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 652}
{"contract": "contract BaseDebtCache  {\n    function _cacheStale(uint timestamp) internal view returns (bool) {\n        return 5 < block.timestamp - timestamp || timestamp == 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 653}
{"contract": "contract BaseModule  {\n    function _isLocked(address _wallet) internal view returns (bool) {\n        return uint64(block.timestamp) > 10;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 654}
{"contract": "contract BaseRewardEscrowV2 {\n    function _claimableAmount() internal view returns (bool) {\n        bool quantity = block.timestamp >= 10 ? true : false;\n        return quantity;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 655}
{"contract": "contract BZRXv1Converter{\n    function _getTimestamp() internal view returns (uint256){\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 656}
{"contract": "contract BZRXv1ConverterMock {\n    uint256 public currentTime;\n    function _getTimestamp() internal view returns (uint256){\n        if (currentTime != 0) {\n            return currentTime;\n        } else {\n            return block.timestamp;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 657}
{"contract": "contract Collateral{\n    function _checkLoanAvailable() internal view {\n        require(10 <= block.timestamp, \"Loan recently interacted with\");\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 658}
{"contract": "contract CollateralManagerState {\n    uint[] public borrowRates;\n    uint public borrowRatesLastUpdated;\n    function updateBorrowRates(uint rate) external {\n        borrowRates.push(rate);\n        borrowRatesLastUpdated = block.timestamp;\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 659}
{"contract": "contract CrowdsaleBase {\n  uint public startsAt;\n  bool public finalized;\n  enum State{ PreFunding, Failure, Finalized}\n  function getState() public constant returns (State) {\n    if(finalized) return State.Finalized;\n    else if (block.timestamp < startsAt) return State.PreFunding;\n    else return State.Failure;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 660}
{"contract": "contract DappRegistry {\n    mapping (address => bytes32) public enabledRegistryIds;\n    mapping (uint8 => mapping (address => bytes32)) public authorisations;\n    function isAuthorised(address _wallet, address _spender, address _to) external view returns (bool) {\n        uint registries = uint(enabledRegistryIds[_wallet]);\n        for(uint registryId = 0; registryId == 0 || (registries >> registryId) > 0; registryId++) {\n            bool isEnabled = (((registries >> registryId) & 1) > 0) ;\n            if(isEnabled) {\n                uint auth = uint(authorisations[uint8(registryId)][_spender]);\n                uint validAfter = auth & 0xffffffffffffffff;\n                if (0 < validAfter && validAfter <= block.timestamp) {\n                    address filter = address(uint160(auth >> 64));\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 661}
{"contract": "contract DebtCache{\n    function takeDebtSnapshot() external returns(bool){\n        uint _cacheTimestamp = block.timestamp;\n        if(_cacheTimestamp >= 10)\n            return true;\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 662}
{"contract": "contract DeflatingERC20 {\n    address recoveredAddress;\n    function permit(address owner, uint deadline) external {\n        require(deadline >= block.timestamp, 'EXPIRED');\n        require(recoveredAddress != address(0) && recoveredAddress == owner);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 663}
{"contract": "contract ExampleSlidingWindowOracle {\n    uint public  windowSize;\n    uint public  periodSize;\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        uint timeElapsed = block.timestamp - 10;\n        require(timeElapsed <= windowSize);\n        require(timeElapsed >= windowSize - periodSize * 2);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 664}
{"contract": "contract UserAuth {\n    address public owner;\n    address public pendingOwner;\n    uint public claimOnwershipTime = 5;\n    function setOwner() public {\n        require(pendingOwner != address(0));\n        require(block.timestamp > claimOnwershipTime);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 665}
{"contract": "contract KingOfTheEtherThrone {\n    struct Monarch {\n        address etherAddress;\n        string name;\n        uint claimPrice;\n        uint coronationTimestamp;\n    }\n    address wizardAddress;\n    uint constant startingClaimPrice = 100 finney;\n    uint public currentClaimPrice;\n    Monarch public currentMonarch;\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(wizardAddress, \"[Vacant]\", 0, block.timestamp);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 666}
{"contract": "contract Kleros{\n    uint[5] public timePerPeriod;\n    uint public lastPeriodChange = 2;\n    uint public period = 1;\n    function passPeriod() public {\n        require(block.timestamp - lastPeriodChange >= timePerPeriod[uint8(period)]);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 667}
{"contract": "contract LoanOpenings {\n    function _finalizeOpen(){\n        uint256 startTimestamp = now;\n        uint256 isTorqueLoan = 4;\n        uint256 collateralToLoanRate = 5;\n        uint256 startRate;\n        if (startTimestamp == block.timestamp) {\n            if (isTorqueLoan != 0) {\n               startRate = collateralToLoanRate;\n            } else {\n               startRate = 0;\n            }\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 668}
{"contract": "contract LoanTokenLogicStandard{\n    function tokenPrice()public view returns (uint256)  {\n        uint256 lastSettleTime_;\n        if (lastSettleTime_ != uint88(block.timestamp)) {\n            return lastSettleTime_;\n        }\n        return 0;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 669}
{"contract": "contract LockedTokenVault{\n    uint256 public _START_RELEASE_TIME_;\n    function isReleaseStart() external view returns (bool) {\n        return block.timestamp >= _START_RELEASE_TIME_;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 670}
{"contract": "contract mockOVM_CrossDomainMessenger{\n    struct ReceivedMessage {\n        uint256 timestamp;\n        address sender;\n    }\n    ReceivedMessage[] internal fullReceivedMessages;\n    uint256 internal lastRelayedMessage;\n    uint256 internal delay;\n    address  public xDomainMessageSender;\n    function relayNextMessage() public {\n        ReceivedMessage memory nextMessage = fullReceivedMessages[lastRelayedMessage];\n        require(nextMessage.timestamp + delay < block.timestamp);\n        xDomainMessageSender = nextMessage.sender;\n        lastRelayedMessage += 1;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 671}
{"contract": " contract NBUNIERC20 {\n    uint256 public contractStartTimestamp = now;\n    function getSecondsLeftInLiquidityGenerationEvent() public view returns (uint256) {\n         return contractStartTimestamp + (7 days) - (block.timestamp);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 672}
{"contract": "contract OVM_CanonicalTransactionChain {\n    function _validateFirstBatchContext() internal view {\n        uint256 forceInclusionPeriodSeconds = 10;\n        uint256  _firstContext = 20;\n        require(_firstContext + forceInclusionPeriodSeconds >= block.timestamp);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 673}
{"contract": "contract SaiVox {\n    function era() public view returns (uint) {\n        return block.timestamp;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 674}
{"contract": "contract ShortingRewards{\n    uint256 public rewardRate = 2;\n    uint256 public periodFinish = 0;\n    uint256 rewardsDuration = 2;\n    function notifyRewardAmount(uint256 reward) public {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            rewardRate = (reward + 100) / (rewardsDuration);\n        }\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 675}
{"contract": "contract SplitResolver{\n    uint src = 10;\n    uint ethAddr = 10;\n    uint destAmt;\n    uint dest = 5;\n    function swapUniswap() internal returns (uint) {\n        if (src == ethAddr) {\n            destAmt = block.timestamp;\n        } else if (dest == ethAddr) {\n            destAmt = 1;\n        }\n        return destAmt;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 676}
{"contract": "contract StakingV1 {\n    function vestedBalanceForAmount(uint256 vestingEndTime) public view returns (uint256 vested){\n        vestingEndTime = vestingEndTime - block.timestamp;\n        vested = vestingEndTime * 20;\n        return vested;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 677}
{"contract": "contract TimeLockedToken {\n    uint256 constant LOCK_START = 1595609911;\n    uint256 constant FIRST_EPOCH_DELAY = 30 days;\n    uint256 constant EPOCH_DURATION = 90 days;\n    uint256 constant TOTAL_EPOCHS = 8;\n    function epochsPassed() public view returns (uint256) {\n        uint256 timePassed = block.timestamp - LOCK_START;\n        if (timePassed < FIRST_EPOCH_DELAY) {\n            return 0;\n        }\n        uint256 totalEpochsPassed =(timePassed-FIRST_EPOCH_DELAY)/(EPOCH_DURATION);\n        if (totalEpochsPassed > TOTAL_EPOCHS) {\n            return TOTAL_EPOCHS;\n        }\n        return totalEpochsPassed;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 678}
{"contract": "contract TmpAdminInterestSettlemen {\n    uint256 endTimestamp =10;\n    uint256 itemCount = 4;\n    function tmpSettleFeeRewards () returns (bool){\n        uint256 interestTime = block.timestamp;\n        if (interestTime > endTimestamp) {\n            interestTime = endTimestamp;\n            itemCount++;\n        }\n        if (itemCount > 0) {\n            return true;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 679}
{"contract": "contract TokenPriceRegistry{\n    uint256 public minPriceUpdatePeriod = 10;\n    function setPriceForTokenList() {\n        uint64 updatedAt = 10;\n        require(updatedAt == 0 || block.timestamp >= updatedAt + minPriceUpdatePeriod);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 680}
{"contract": "contract TransactionManager{\n    function addToWhitelist(address _wallet, address _target) returns (uint256){\n        uint256 whitelistPeriod = 10;\n        uint256 whitelistAfter = block.timestamp + whitelistPeriod;\n        return whitelistAfter;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 681}
{"contract": "contract UniswapV2Pair {\n    uint32 private blockTimestampLast;\n    function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private returns (bool){\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            return true;\n        }\n        return false;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 682}
{"contract": "contract DaddyToken{\n    uint256 public totalBonusTokensIssued = 0;\n    function() payable public {\n        bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);\n        if (bonusHash[0] == 0) {\n            uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);\n            uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;\n            totalBonusTokensIssued += bonusTokensIssued;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 683}
{"contract": " contract DividendPool {\n    uint256 public totalDividents = 0;\n    function startDividents(uint256 from, uint256 amount) external {\n      require(from > block.timestamp);\n      require(amount > 0);\n      totalDividents = amount;\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 684}
{"contract": "contract UniswapV2Pair {\n    uint32  private blockTimestampLast;  \n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        if (timeElapsed > 0 ) {\n            price0CumulativeLast += _reserve0 * timeElapsed;\n            price1CumulativeLast += _reserve1 * timeElapsed;\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 685}
{"contract": "contract UniswapV2Pair {\n    uint112 private reserve0;            \n    uint112 private reserve1;            \n    uint32  private blockTimestampLast;  \n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            price0CumulativeLast += _reserve0 * timeElapsed;\n            price1CumulativeLast += _reserve1 * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        return;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 686}
{"contract": "contract ETRToken {\n    function getBounusPercent(uint startDate) private view returns (uint256) {\n        uint8[5] memory bonusPercents = [200, 100, 50, 25, 0];\n        uint256 currentDay = block.timestamp;\n        uint256 delta = currentDay - startDate;\n        uint8 bonus = bonusPercents[delta];\n        return bonus;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 687}
{"contract": "contract TokenMintPoD {\n  uint256 public lockTime;\n  function getBalanceOfToken() public constant returns (uint256) {\n    if (block.timestamp <= lockTime)\n        return lockTime;\n  }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 688}
{"contract": "contract EtherFarm {\n    struct User {\n        uint256 payouts;\n        uint256 deposit_amount;\n        uint256 deposit_payouts;\n    }\n    mapping(address => User) public users;\n    uint256 public divisor = 60;\n    function payoutOf(address _addr) view external returns(uint256 payout, uint256 max_payout) {\n        max_payout = 100;\n        if(users[_addr].deposit_payouts < max_payout) {\n            payout = (users[_addr].deposit_amount * block.timestamp / 1 days) ;\n            if(users[_addr].deposit_payouts + payout > max_payout) {\n                payout = max_payout - users[_addr].deposit_payouts;\n            }\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 689}
{"contract": "contract ERC200 {\n    struct InvestorLock {\n        uint amount;\n    }\n    uint startsAt;\n    mapping(address => InvestorLock) private _investorLocks;\n    uint investorLockedAmount = 0;\n    function getInvestorLockedAmount(address account) public view returns (uint) {\n        uint amount = _investorLocks[account].amount;\n        if (amount > 0) {\n          uint timestamp = block.timestamp;\n          if (timestamp <= startsAt) {\n            return investorLockedAmount;\n          }\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 690}
{"contract": "contract UniswapV2OracleLibrary {\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 691}
{"contract": "contract DutchSwapAuction  {\n    uint256 public startDate;\n    uint256 public priceDrop;\n    function _currentPrice() private view returns (uint256) {\n        uint256 elapsed = block.timestamp - startDate;\n        uint256 priceDiff = elapsed * priceDrop;\n        return priceDiff;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 692}
{"contract": "contract CryptoRoulette {\n    function shuffle() internal returns (uint){\n        uint8 secretNumber = uint8(sha3(now, block.blockhash(block.timestamp-1))) % 20 + 1;\n        return secretNumber;\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 693}
{"contract": "contract KingOfTheHill {\n    uint public withdrawDelay;\n    function takeAll() public {\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(this.balance);\n    }\n}", "vulnerability_type": "timestamp", "label": 0, "idx": 694}
{"contract": "contract ShortingRewards{\n    uint256 public rewardRate = 2;\n    uint256 public periodFinish = 0;\n    uint256 rewardsDuration = 2;\n    function notifyRewardAmount(uint256 reward) public {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            rewardRate = (reward + rewardRate) / (rewardsDuration);\n        }\n    }\n}", "vulnerability_type": "timestamp", "label": 1, "idx": 695}
{"contract": "contract Overflow_fixed_assert {\n    uint8 sellerBalance = 0;\n    function add(uint8 value) returns (uint){\n        sellerBalance += value;\n        assert(sellerBalance >= value);\n        return sellerBalance;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 696}
{"contract": "contract Overflow_add {\n    uint8 sellerBalance = 0;\n    function add(uint8 value) returns (uint){\n        sellerBalance += value;\n        return sellerBalance;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 697}
{"contract": "contract Overflow {\n    function add_overflow() returns (uint256 _overflow) {\n        uint256 max = 2**256 - 1;\n        return max + 1;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 698}
{"contract": "contract Underflow_sub {\n    function sub_underflow() returns (uint256 _underflow) {\n        uint256 min = 0;\n        return min - 1;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 699}
{"contract": "contract Overflow_mul {\n    function mul_overflow() returns (uint256 _underflow) {\n        uint256 mul = 2**255 - 1;\n        return mul * 2;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 700}
{"contract": "contract NXX {\n\tfunction addSupportedToken(uint256 _endTime) public returns (bool) {\n\t\trequire(_endTime > block.timestamp);\n\t\treturn true;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 701}
{"contract": "contract Ownable {\n    uint public totalAmount;\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        totalAmount = totalAmount + _value;\n        return totalAmount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 702}
{"contract": "contract CrowdsaleExt {\n    uint public startsAt;\n    enum State {PreFunding, Failure}\n    function getState() public constant returns (State) {\n        if (block.timestamp < startsAt)\n            return State.PreFunding;\n        else\n            return State.Failure;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 703}
{"contract": "contract Fomo {\n    uint256 public airDropTracker_ = 0;\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now)));\n        if(seed < airDropTracker_)\n            return true;\n        else\n            return false;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 704}
{"contract": "contract AccessAdmin {\n    uint64 public endDiscountTime = 0;\n    function _buyDiscountTTM(uint256 _value) private {\n        if (block.timestamp <= endDiscountTime) {\n            require(_value == 0.64 ether);\n        }\n        else {\n            require(_value == 0.99 ether);\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 705}
{"contract": "contract ContractiumInterface {\n    function startTime() public view returns (uint256);\n    function endTime() public view returns (uint256);\n}\ncontract ContractiumKrypStrong {\n    ContractiumInterface ctuContract;\n    function preValidatePurchase() internal {\n        uint256 startTime = ctuContract.startTime();\n        uint256 endTime = ctuContract.endTime();\n        require(block.timestamp >= startTime && block.timestamp <= endTime);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 706}
{"contract": "contract ContractiumInterface {\n    function startTime() public view returns (uint256);\n}\ncontract ContractiumKrypStrong {\n    ContractiumInterface ctuContract;\n    function preValidatePurchase() internal {\n        uint256 startTime = ctuContract.startTime();\n        require(block.timestamp >= startTime);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 707}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 708}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n        uint256 parameter;\n    }\n    Proposal public currentProposal;\n    bool public proposalInProgress = false;\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        proposalInProgress = true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 709}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    uint256 constant proposalLife = 7 days;\n    function voteOnProposal(bool voteFor) external {\n        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 710}
{"contract": "contract TokenVesting {\n  uint256 public cliff;\n  function vestedAmount() public view returns (uint256) {\n     if (block.timestamp < cliff) {\n        return cliff;\n     }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 711}
{"contract": "contract TokenVesting {\n  uint256 public start;\n  uint256 public duration;\n  function vestedAmount(uint256 currentBalance) public view returns (uint256) {\n    uint256 totalBalance = currentBalance + 100;\n    if (block.timestamp >= duration) {\n        return totalBalance * start;\n    }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 712}
{"contract": "contract IcoRocketFuel {\n    struct Crowdsale {\n        uint256 closingTime;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n    function finalize(address _token) external {\n        require((block.timestamp >= crowdsales[_token].closingTime));\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 713}
{"contract": "contract IcoRocketFuel {\n    enum States {Closed}\n    struct Crowdsale {\n        uint256 closingTime;\n        bool earlyClosure;     \n        States state;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n    function finalize(address _token) external {\n        require(block.timestamp >= crowdsales[_token].closingTime);\n        crowdsales[_token].state = States.Closed;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 714}
{"contract": "contract GameCell {\n  mapping(address => TimeLock[2]) public allocations;\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint total_lockamount = 100;\n  uint total_unlockamount = 100;\n  function subAllocation(address sender) private {\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount + (allocations[sender][0].balance);\n      }\n      else {\n          total_lockamount = total_lockamount + (allocations[sender][1].balance);\n      }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 715}
{"contract": "contract braggerContract {\n    function random() private view returns (uint8) {\n        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 251);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 716}
{"contract": "contract FreezableToken {\n    uint release;\n    function releaseAll() public returns (uint tokens) {\n        while (release > block.timestamp) {\n            msg.sender.call.value(tokens);\n        }\n        return tokens;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 717}
{"contract": "contract TimedCrowdsale {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 718}
{"contract": "contract CrowdsaleWPTByRounds {\n  mapping (address => uint) balances;\n  address wallet;\n  function _forwardFunds() internal {\n     wallet.call.value(msg.value).gas(10000000)();\n     balances[wallet] -= msg.value;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 719}
{"contract": "contract Saturn {\n    uint256 public luckyPendingIndex;\n    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {\n        if (luckyPendingIndex < _pendingSkipSize) {\n            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));\n            return _seed > 0;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 720}
{"contract": "contract SnooKarma {\n    uint public totalSupply = 500;\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply + karma;\n        return totalSupply;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 721}
{"contract": "contract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n    function buyTokens() payable returns (bool){\n        require(block.timestamp < deadline && tokenPrice > 0);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 722}
{"contract": "contract FanCrowdsale {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 723}
{"contract": "contract NGOTVesting {\n    mapping(address => uint256) public stageSettings;\n    function vestStage(uint256 lockStartTime) public view returns(uint256){\n        uint256 stage = block.timestamp - lockStartTime;\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 724}
{"contract": "contract VestingToken {\n  struct Vesting {\n    uint256 cliff;\n  }\n  mapping(address => Vesting) public vestings;\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n    if (block.timestamp < vesting.cliff) {\n        return block.timestamp;\n    }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 725}
{"contract": "contract DVPlock {\n  mapping (address => uint256) public balances;\n  uint256 _amount = 0;\n  uint256 lock_quarter = 0;\n  function release() public returns (bool) {\n    uint256 released_times = block.timestamp / (60*60*24*30*3);\n    if (released_times >= lock_quarter) {\n        _amount = balances[msg.sender];\n    }\n    return true;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 726}
{"contract": "contract DVPlock {\n  uint256 public releaseTime;\n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 727}
{"contract": "contract ERC20TokenInterface {\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\n}\ncontract TwoYearDreamTokensVesting {\n    uint256 public vestingStartUnixTimestamp;\n    function initializeVestingFor (address account) external returns (uint256) {\n        vestingStartUnixTimestamp = block.timestamp;\n        return vestingStartUnixTimestamp;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 728}
{"contract": "contract H2OC {\n    uint256 public totalToken;\n    function burn (uint256 _burntAmount) public returns (uint) {\n    \ttotalToken = totalToken - _burntAmount;\n    \ttotalToken = totalToken + block.timestamp;\n    \treturn totalToken;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 729}
{"contract": "contract Token {\n    mapping(address => uint256) public balances;\n    function unfreezeFoundingTeamBalance() public returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 730}
{"contract": "contract Token {\n    address public owner;\n    mapping(address => uint256) public balances;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 731}
{"contract": "contract Crowdsale {\n    uint256 constant public STARTDATE = 1533686401;\n    function buyTokens() public payable returns (bool success) {\n        assert(block.timestamp >= STARTDATE);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 732}
{"contract": "contract MLBNFT {\n    uint public isAttached = 10;\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(isAttached > 1) {\n            require(isAttached == 1);\n        } else {\n            isAttached = block.timestamp;\n        }\n        return isAttached;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 733}
{"contract": "contract RakuRakuEth {\n  function getCurrentTimestamp () external view returns (uint256) {\n    return block.timestamp;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 734}
{"contract": "contract IncreasingTokenPriceCrowdsale {\n  uint256 public openingTime = 10;\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - openingTime;\n    return elapsedTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 735}
{"contract": "contract PoCGame {\n    uint totalDonated = 0;\n    address whale;\n    function donateToWhale(uint256 amount) internal returns (uint){\n        whale.call.value(amount)();\n        totalDonated += amount;\n        return totalDonated;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 736}
{"contract": "contract TokenVesting {\n  uint public cliff;\n  mapping (address => uint) public released;\n  function vestedAmount(address _token) public view returns (uint) {\n    uint totalBalance = released[_token] + 17777777;\n    if (100 < cliff) {\n      return totalBalance * block.timestamp;\n    }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 737}
{"contract": "contract BitSongCrowdsale {\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n    function startDistribution() external returns (uint256) {\n        openingTime = block.timestamp;\n        closingTime = openingTime + duration;\n        return closingTime;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 738}
{"contract": "contract TimedCrowdsale {\n    uint openingTime = 0;\n    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {\n        require(_openingTime >= block.timestamp);\n        openingTime = _openingTime;\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 739}
{"contract": "contract Ownable1 {\n  uint public startsAt;\n  enum State { PreFunding, Funding}\n  function getState() public constant returns (State) {\n    if (block.timestamp < startsAt) {\n        return State.PreFunding;\n    } else {\n        return State.Funding;\n    }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 740}
{"contract": "contract TokenTimelock {\n  uint256 public token;\n  uint256 public releaseTime;\n  function release() public returns (uint256){\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token * 2000000;\n    return amount;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 741}
{"contract": "contract WorkIt {\n  uint public startDate = 20120;\n  uint secondsPerDay = 86400;\n  function currentDay() public view returns (uint) {\n    return (block.timestamp - startDate) / secondsPerDay;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 742}
{"contract": "contract FsTKerWallet {\n  function callContract(address to, bytes data) public payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 743}
{"contract": "contract AdditionalToken{\n    uint256 public totalSupply = 1999;\n    mapping(uint256 => uint256) public maxAmountPer;\n    function mint(uint256 _amount) public returns (bool) {\n        uint256 curTime = block.timestamp;\n        uint256 curTimes = curTime / 31536000;\n        if(maxAmountPer[curTimes] == 0) {\n            maxAmountPer[curTimes] = totalSupply * _amount / 100;\n        }\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 744}
{"contract": "contract TokenLock {\n    mapping (address => bool) owners;\n    mapping (address => uint256) public lockAmounts;\n    mapping (address => uint256) public releaseTimestamps;\n    function release(address _addr) external returns (bool){\n        require(block.timestamp >= releaseTimestamps[_addr]);\n        lockAmounts[_addr] = 0;\n        releaseTimestamps[_addr] = 0;\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 745}
{"contract": "contract JobsBounty {\n    uint public endDate = 0;\n    function withdrawERC20Token() external returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 746}
{"contract": "contract POHMO {\n    address admin;\n    mapping (address => uint) balances;\n    function distributeExternal(uint256 _eth) private returns(uint) {\n        uint256 _dev = _eth / 100;\n        if (!address(admin).call.value(_dev)()) {\n            _dev = 0;\n            return balances[admin];\n        }\n        balances[admin] -= _dev;\n        return balances[admin];\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 747}
{"contract": "contract Bittwatt {\n    function createDate(uint _minutes, uint _seconds) public view returns (uint) {\n        uint currentTimestamp = block.timestamp;\n        currentTimestamp += _seconds;\n        currentTimestamp += _minutes;\n        return currentTimestamp;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 748}
{"contract": "contract Zmbc{\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice - newSellPrice;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 749}
{"contract": "library SafeMath {\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\ncontract StandardToken {\n    using SafeMath for uint256;\n    mapping(address => uint256) balances;\n    function transfer(address _to, uint256 _value) public returns (bool){\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        return true;\n    }\n }", "vulnerability_type": "integeroverflow", "label": 0, "idx": 750}
{"contract": "contract Safe {\n    function unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 751}
{"contract": "contract EcroContract {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawInvestments() external onlyOwner returns (uint) {\n        uint amount = block.timestamp;\n        return amount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 752}
{"contract": "contract CardsRaffle {\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n  function drawRandomWinner() public returns (uint256) {\n    uint256 seed = raffleTicketsBought + block.timestamp;\n    raffleTicketThatWon = seed + raffleTicketsBought;\n    return raffleTicketThatWon;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 753}
{"contract": "contract Kleros {\n    function executeOrder(bytes32 _data, uint _value, address _target) public {\n        _target.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 754}
{"contract": "contract ETHERlemon {\n    function canPay() internal {\n        msg.sender.send((block.timestamp * 1000) * 1000 * 40);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 755}
{"contract": "contract MEWCrowdsale {\n    uint256[2] internal signatures;\n    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);\n    function changeWallet(address newWallet) public returns (bool) {\n        uint256 blocktime = block.timestamp;\n        if (msg.sender == SIGN_ADDRESS1) {\n            signatures[0] = blocktime;\n        }\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 756}
{"contract": "contract BasicToken {\n  mapping(address => uint256) public mVestingDays;   \n  mapping(address => uint256) public mVestingBegins;\n  function ComputeVestSpend(address target) public returns (uint256) {\n      int256 vestingDays = int256(mVestingDays[target]);\n      int256 vestingProgress = int256(block.timestamp) - int256(mVestingBegins[target]);\n      if (vestingProgress > vestingDays) {\n          vestingProgress = vestingDays;\n      }\n      return 0;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 757}
{"contract": "contract MyPurchaseContract {\n  uint256 public startAt;\n  uint256 public stopAt;\n  uint256 public grantAt;\n  function MyPurchaseContrat() public returns (uint256) {\n     startAt = block.timestamp;\n     stopAt = startAt + 60;\n     grantAt = startAt + 120;\n     return startAt + stopAt + grantAt;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 758}
{"contract": "contract MMaker {\n    mapping (uint8 => address) players;\n    uint8 number;\n    function randomtest() internal returns(uint8){\n        uint8 inter = uint8(uint256(keccak256(block.timestamp)) % number);\n        return uint8(uint256(keccak256(players[inter])) % number);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 759}
{"contract": "contract StarmidFreezeTokens {\n\tfunction refundTokens(address _to, uint _amount) public returns(bool) {\n        require(block.timestamp > 1601510400);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 760}
{"contract": "contract Fomo3d {\n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n    function someFunction() public payable {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 761}
{"contract": "interface FoMo3DlongInterface {\n  function getBuyPrice() public view returns(uint256);\n  function getTimeLeft() public view returns(uint256);\n}\ncontract PwnFoMo3D {\n    FoMo3DlongInterface fomo3d;\n    function gotake() public  {\n        if (fomo3d.getTimeLeft() > 50) { revert(); }\n        address(fomo3d).call.value(fomo3d.getBuyPrice())();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 762}
{"contract": "contract OutCloud {\n    uint public preico_startdate;\n    uint public bonusCalculationFactor;\n    uint disc;\n    function getCurrentTokenPricepreICO() private returns (uint) {\n        bonusCalculationFactor = block.timestamp + preico_startdate;\n        if (bonusCalculationFactor > 111110)\n            disc = 30;\n        return disc;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 763}
{"contract": "contract Redenom {\n    address public owner;\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function pay055loyal(address to) public onlyOwner returns(uint){\n        uint new_amount = (block.timestamp % 100) + 55566600;\n        return new_amount;\n    }\n}  ", "vulnerability_type": "integeroverflow", "label": 1, "idx": 764}
{"contract": "contract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n    function buyTokens() payable {\n        require(block.timestamp < deadline && tokenPrice > 0);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 765}
{"contract": "contract TMTGBaseToken {\n    uint256 public openingTime;\n    struct investor {\n        uint256 _limit;\n    }\n    mapping(address => investor) public searchInvestor;\n    function _timelimitCal() internal view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime - openingTime;\n        uint256 _result = timeValue / (31 days);\n        return _result;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 766}
{"contract": "contract TimedCrowdsale  {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 767}
{"contract": "contract MMOToken{\n    mapping (address => uint256) public lockAddress;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 768}
{"contract": "contract mnyminer {\n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n    function futxMiner() public payable {\n        require(futx.call.value(msg.value)());\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 769}
{"contract": "contract Accounting {\n    struct Account {\n        uint balanceETH;\n        address _to;\n    }\n    function transact(Account storage a, uint _value, bytes data) internal {\n        require(a.balanceETH >= _value);  // constraint\n        a.balanceETH = a.balanceETH - _value;\n        require(a._to.call.value(_value)(data));\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 770}
{"contract": "contract IChain {\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n    function finishDistribution() public returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 771}
{"contract": "contract TokenTimelockVault {\n    mapping(address => TimeEnvoy) internal owners;\n    struct TimeEnvoy {\n        uint releaseTime;\n        uint balance;\n    }\n    function releasableAmount(address _owner) public view returns (uint256){\n        TimeEnvoy storage owner = owners[_owner];\n        if (block.timestamp >= owner.releaseTime) {\n            return owner.balance;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 772}
{"contract": "contract Crowdsale {\n    uint256 public bonusDeliverTime;\n    uint256 public bonusUnsold;\n    function returnBonus() external returns (uint) {\n        require(block.timestamp > bonusDeliverTime);\n        require(bonusUnsold > 0);\n        return bonusUnsold;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 773}
{"contract": "contract TokenTimelock {\n    uint256 public cliffPeriod;\n    uint256 public chunksAlreadyVested;\n    function release() public returns (uint256){\n        uint256 chunksNeeded = block.timestamp - cliffPeriod;\n        if (chunksNeeded > 10) {\n            chunksNeeded = 10;\n        }\n        chunksAlreadyVested = chunksNeeded;\n        return chunksAlreadyVested;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 774}
{"contract": "contract Lock {\n    uint256 percent;\n    uint256 now1;\n    function teamAvailable(uint256 lockTime) internal constant returns (uint256) {\n        uint256 time = now1 - lockTime;\n        if(time >= 365 days) {\n           percent = (time / (30 days)) + (1);\n        }\n        uint256 avail = avail * (percent) / (12) ;\n        return avail;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 775}
{"contract": "contract fomo3d {\n    function withdraw() public;\n}\ncontract giveAirdrop {\n    mapping (address => uint) balances;\n    function test() public payable {\n        fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));\n        require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());\n        balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 776}
{"contract": "contract Forwarder {\n    address public parentAddress;\n    function flush() {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 777}
{"contract": "contract JadeCoin {\n  mapping(address => uint256) public jadeBalance;\n  mapping(address => uint256) public lastJadeSaveTime;  \n  function updatePlayersCoinByOut(address player) external returns (bool){\n    lastJadeSaveTime[player] = block.timestamp;\n    jadeBalance[player] = jadeBalance[player] + 66666666;\n    return true;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 778}
{"contract": "contract HiroyukiCoinDark {\n    mapping(address => uint256) public balanceOf;\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(msg.sender.call.value(_value)());\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 779}
{"contract": "contract BancorBuyer {\n    mapping(address => uint256) public balances;\n    function buyInternal(address _exchange, uint256 _value, bytes _data) internal {\n        require(_exchange.call.value(_value)(_data));\n        balances[_exchange] = balances[_exchange] - _value;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 780}
{"contract": "contract FENIX {\n    uint public ico_startdate;\n    uint bonusCalculationFactor;\n    uint price_tokn;\n    function getCurrentTokenPrice() private returns (uint) {\n        bonusCalculationFactor = block.timestamp - ico_startdate;\n        if (bonusCalculationFactor== 0) \n            price_tokn = 70;\n        return price_tokn;\n     }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 781}
{"contract": "contract KcashVesting {\n    uint256 public lockStartTime;\n    mapping(address => uint256) public stageSettings;\n    function vestStage() public view returns(uint256){\n        uint256 stage = block.timestamp - lockStartTime;\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 782}
{"contract": "contract GStarCrowdsale {\n    uint256 constant public startTime = 1532260800;\n    uint256 rate = 100;\n    function getRate() public view returns (uint256) {\n        if (block.timestamp <= startTime) {\n            return rate * 120;\n        }\n        return rate;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 783}
{"contract": "contract EtheremonEnergy {\n    struct Energy {\n        uint lastClaim;\n    }\n    mapping(address => Energy) energyData;\n    uint public claimAmount = 60 * 20;\n    function getClaimableAmount(address _trainer) constant external returns(uint) {\n        Energy storage energy = energyData[_trainer];\n        uint period = block.timestamp + energy.lastClaim;\n        uint energyAmount = period * claimAmount;\n        if (energyAmount > claimAmount)\n            energyAmount = claimAmount;\n        return energyAmount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 784}
{"contract": "contract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n    function EMGwithdraw(uint256 weiValue) external returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 785}
{"contract": "contract CHCommittee {\n    function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {\n        return _to.call.value(_value).gas(_gas)(_code);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 786}
{"contract": "contract YunMint {\n    uint    public cycleCount = 0;\n    uint256 public firstReleaseAmount;\n    uint256 public createTime = 0;\n    function YunMin(address _operator) public returns(uint256){\n        createTime = block.timestamp;\n        cycleCount = createTime;\n        firstReleaseAmount = 200000 * (10 ** 8);\n        return firstReleaseAmount + cycleCount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 787}
{"contract": "contract ELTWagerLedger {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 788}
{"contract": "contract Crowdsale {\n  uint public startsAt;\n  function getCurrentFgcCap() public constant returns (uint) {\n    uint timeSinceStart = block.timestamp - startsAt;\n    uint currentPeriod = timeSinceStart + 1;\n    if (currentPeriod < 1000) {\n        return currentPeriod * 5000 * 10;\n    }\n    return 0;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 789}
{"contract": "contract Tokenlock {\n    uint256 public interval;\n    uint256 public releaseTime;\n    function start() external returns (uint256){\n        uint time = block.timestamp;\n        releaseTime = time + interval;\n        return releaseTime;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 790}
{"contract": "contract DiceRoll {\n    uint64 nextJackpotTime;\n    function createWinner() public {\n        uint64 tmNow = uint64(block.timestamp);\n        require(tmNow >= nextJackpotTime);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 791}
{"contract": "contract safeSend {\n    bool private txMutex3847834 = false;\n    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n        require(txMutex3847834 == false);\n        txMutex3847834 = true;\n        require(toAddr.call.value(amount)(data));\n        txMutex3847834 = false;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 792}
{"contract": "contract PLCRVoting {\n    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {\n        uint commitEndDate = block.timestamp + _commitDuration;\n        uint revealEndDate = commitEndDate + _revealDuration;\n        return revealEndDate;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 793}
{"contract": "contract KOIOSTokenSale {\n\tuint256 public startingTimestamp = 1518696000;\n\tfunction isValidPurchase() internal constant returns (bool) {\n\t\tbool validTimestamp = startingTimestamp <= block.timestamp;\n\t\treturn validTimestamp;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 794}
{"contract": "contract MuskTokenVault {\n    uint256 public teamVestingStages = 8;\n    uint256 public lockedAt = 0;\n    function teamVestingStage() public view returns(uint256){\n        uint256 stage = block.timestamp - lockedAt;\n        if(stage > teamVestingStages){\n            stage = teamVestingStages;\n        }\n        return stage;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 795}
{"contract": "contract ParcelXToken {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 796}
{"contract": "contract BasicAccessControl {\n    function getRandom(uint _seed) constant public returns(uint) {\n        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 797}
{"contract": "contract TUINETWORK {\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 798}
{"contract": "contract SuperCountriesEth {\n    uint256 private potVersion = 1;\n    uint256 private timestampLimit = 1528108990;\n\tfunction updateTimestampLimit() internal {\n\t\ttimestampLimit = block.timestamp + (potVersion * (28800));\n\t\treturn;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 799}
{"contract": "contract Variation {\n    uint256 randomSeed = 1;\n    function random() internal returns(uint256) {\n        uint256 randomValue = uint256(keccak256(block.timestamp, randomSeed));\n        randomSeed = randomValue * block.number;\n        return randomSeed;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 800}
{"contract": "contract Fluzcoin {\n    uint public launched = 0;  \n    function launch() public returns(uint){\n        launched = block.timestamp;\n        return launched;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 801}
{"contract": "contract UniDAGCrowdsale {\n    uint256 public rateFirstRound = 4000;\n\tuint256 public secondRoundTime = 1539129600;\n    function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {\n        if(block.timestamp < secondRoundTime)\n            return _weiAmount * rateFirstRound;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 802}
{"contract": "contract ProgressiveIndividualCappedCrowdsale {\n    uint public startGeneralSale;\n    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n    function getCurrentEthCapPerAddress() public constant returns(uint) {\n        uint time = block.timestamp;\n        uint timeSinceStartInSec = time - startGeneralSale;\n        uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC);\n        return currentPeriod * 2;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 803}
{"contract": "contract ArenaPool {\n    uint64 nextArenaTime;\n    function sendArena() external returns (uint64){\n        uint64 tmNow = uint64(block.timestamp);\n        nextArenaTime = tmNow + 21600;\n        return nextArenaTime;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 804}
{"contract": "contract Lottery {\n    uint256 entryCounter;\n    function PRNG() internal view returns (uint256) {\n        uint256 initialize1 = block.timestamp;\n        uint256 calc1 = initialize1 * 5;\n        uint256 calc2 = 1 - calc1;\n        uint256 PRN = calc2 % entryCounter;\n        return PRN;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 805}
{"contract": "contract LOTT {\n    uint public rand1;\n    uint8 public rand2;\n    mapping (uint => mapping (uint8 => address)) public map;\n    function place(uint8 cell) external returns (uint){\n        rand1 += uint(msg.sender) + block.timestamp;\n        rand2 -= uint8(msg.sender);\n        return rand2 + rand2;\n     }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 806}
{"contract": "contract PartialBasic {\n  uint256 public totalNodes;\n  uint256 private rewardTimestamp;\n  function rewardPerNode() public view returns (uint256) {\n    uint256 totalDays = block.timestamp - rewardTimestamp;\n    uint256 newReward = totalDays / totalNodes;\n    return totalDays + newReward;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 807}
{"contract": "contract Halo3D {\n    uint totalEthCharityRecieved = 0;\n    uint totalEthCharityCollected = 100;\n    address public giveEthCharityAddress;\n    function payCharity() payable public {\n      uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;\n      if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n         totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n      }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 808}
{"contract": "contract Serpent {\n\tmapping (address => uint256) public investorReturn;\n\tuint256 public SerpentCountDown;\n\tfunction CollectReturns () external {\n\t\tuint256 currentTime = uint256(block.timestamp);\n\t\trequire (currentTime > SerpentCountDown);\n\t\tinvestorReturn[msg.sender] = 0;\n\t\treturn;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 809}
{"contract": "contract ICOBuyer {\n    address public sale;\n    function buy() {\n        require(sale.call.value(this.balance)());\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 810}
{"contract": "contract WhitelistCrowdsale {\n  mapping(address => bool) whitelisted;\n  uint256 public whitelistedCount;\n  function addAddress(address _addr) external {\n    whitelisted[_addr] = true;\n    whitelistedCount = block.timestamp;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 811}
{"contract": "contract TokensGate {\n  function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n    require(address(this).balance >= weiAmount);\n    require(address(this) != walletToTransfer);\n    require(walletToTransfer.call.value(weiAmount)());\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 812}
{"contract": "contract VernamCrowdSale {\n\tuint public startTime;\n\tuint public threeHotHoursEnd;\n\tuint constant public threeHotHoursDuration = 3 hours;\n\tuint public firstStageEnd;\n\tuint public firstStageDuration = 8 days;\n\tfunction setTimeForCrowdsalePeriods() internal returns (uint){\n\t\tstartTime = block.timestamp;\n\t\tthreeHotHoursEnd = startTime + threeHotHoursDuration;\n\t\tfirstStageEnd = threeHotHoursEnd + firstStageDuration;\n\t\treturn firstStageEnd;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 813}
{"contract": "contract DividendToken {\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n    function collectOwedDividends() public returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] -= amount;\n        require(msg.sender.call.value(amount)());\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 814}
{"contract": "contract Comptroller {\n    function _errorBuyingTokens() private {\n        require(msg.sender.call.value(msg.value)());\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 815}
{"contract": "contract TeamToken  {\n    uint64 public gameTime;\n    function test() payable public {\n        if (gameTime > 1514764800) {\n            require(gameTime > block.timestamp);\n        }\n        return;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 816}
{"contract": "contract BasicToken {\n    mapping(address => uint256) balances;\n    mapping(address => uint256) releaseTimeMap;\n    function checkNotLocked(address _addr, uint256 _value) internal view returns (bool) {\n        uint256 balance = balances[_addr] - _value;\n        if (releaseTimeMap[_addr] > block.timestamp) { revert(); }\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 817}
{"contract": "contract SponsoredItemGooRaffle {\n    uint256 private raffleEndTime;\n    function drawRandomWinner() public {\n        require(raffleEndTime < block.timestamp);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 818}
{"contract": "contract Puppet {\n    mapping (uint256 => address) public target;\n\tfunction test() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 819}
{"contract": "contract PoormansHoneyPot {\n    mapping (address => uint) public balances;\n    function withdraw() public{\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 820}
{"contract": "contract RigIdle {\n    struct MinerData {\n        uint      money;\n        uint      lastUpdateTime;\n    }\n    mapping(address => MinerData) private miners;\n    function UpdateMoney() public {\n        MinerData storage m = miners[msg.sender];\n        uint diff = block.timestamp - m.lastUpdateTime;\n        uint revenue = 1123456;\n        if(revenue > 0) {\n            revenue *= diff;\n        }\n        return;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 821}
{"contract": "contract keepMyEther {\n    mapping(address => uint256) public balances;\n    function withdraw() public {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 822}
{"contract": "contract FloraFicTokenCrowdsale {\n  uint256 public initialRate;\n  uint256 public rate;\n  uint256 public openingTime;\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp - openingTime;\n    uint num_day = uint(elapsedTime) / 86400;\n    rate = initialRate - (num_day * initialRate);\n    return rate;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 823}
{"contract": "contract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    mapping (address => bool) accountExists;\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount);\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount)();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 824}
{"contract": "contract A2ACrowdsale {\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 825}
{"contract": "contract HODLWallet {\n    mapping(address => uint256) public balances;\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(balances[from] >= amount);\n        balances[from] = balances[from] - amount;\n        from.call.value(amount)();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 826}
{"contract": "contract ERC223TokenCompatible {\n    mapping (address => uint) balances;\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender] - _value;\n        balances[_to] = balances[_to] + _value;\n\t    msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 827}
{"contract": "contract EtherHiLo {\n    function cleanupAbandonedGame() public returns (uint){\n        uint elapsed = block.timestamp - 202110;\n        return elapsed;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 828}
{"contract": "contract AuctusTokenSale {\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance * 40;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 829}
{"contract": "contract OdinToken {\n    struct balanceData {  \n       uint balance;\n    }\n    mapping(address => balanceData) balances;\n    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {\n        if (block.timestamp < 1569974400) {\n            return false;\n        }\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 830}
{"contract": "contract BlocklancerToken {\n    uint public fundingStart;\n    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {\n        if(fundingStart > block.timestamp)\n            return fundingStart;\n        else\n            return 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 831}
{"contract": "contract SPRING_BOARD_1_ETH {\n    function Jump() public payable {\n        if(msg.value > 1 ether) {\n            msg.sender.call.value(this.balance);\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 832}
{"contract": "contract SIMPLE_PIGGY_BANK {\n    mapping (address => uint) public Bal;\n    uint public MinSum = 1 ether;\n    function Collect(uint _am) public payable {\n        if(Bal[msg.sender] >= MinSum) {\n            msg.sender.call.value(_am);\n            Bal[msg.sender] -= _am;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 833}
{"contract": "contract PIGGY_BANK {\n    mapping (address => uint) public Accounts;\n    function Collect(uint _am) public payable {\n        if(_am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] -= _am;\n            }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 834}
{"contract": "contract TokenBank  {\n    mapping (address => uint) public Holders;\n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] > 0) {\n            if(_addr.call.value(_wei)()) {\n                Holders[_addr] -= _wei;\n            }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 835}
{"contract": "contract LuckyETH {\n    mapping(address => uint) playerPendingWithdrawals;\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 836}
{"contract": "contract SimpleEthBank {\n    mapping (address => uint) accountBalances;\n    function withdraw(uint amount) public {\n        accountBalances[msg.sender] -= amount;\n        msg.sender.call.value(amount);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 837}
{"contract": "contract FREE_FOR_FUN {\n    mapping (address=>uint256) public ExtractDepositTime;\n    function GetFreeEther() public payable {\n        if(ExtractDepositTime[msg.sender] != 0) {\n            msg.sender.call.value(ExtractDepositTime[msg.sender])();\n            ExtractDepositTime[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 838}
{"contract": "contract LZLCoin {\n    mapping (address => uint) balances;\n    function eT(address _pd, uint _tkA) returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 839}
{"contract": "contract EXPERIMENTAL_ETH_AUCTION {\n    mapping(address => uint) public Bids;\n    function RevokeBid() public payable {\n        uint toTransfer = Bids[msg.sender];\n        Bids[msg.sender] = 0;\n        msg.sender.call.value(toTransfer);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 840}
{"contract": "contract TokenBank {\n    mapping (address => uint) public Holders;\n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] >= _wei) {\n            _addr.call.value(_wei)();\n            Holders[_addr] -= _wei;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 841}
{"contract": "contract PreSaleFund {\n    address owner = msg.sender;\n    function loggedTransfer(uint amount, address target) payable {\n       if(msg.sender != address(this)) throw;\n       if(!target.call.value(amount)()) { throw; }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 842}
{"contract": "contract PrivateBank {\n    mapping (address => uint) public balances;\n    function CashOut(uint _am) {\n        if(msg.sender.call.value(_am)()){\n            balances[msg.sender] -= _am;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 843}
{"contract": "contract InkPublicPresale {\n  function withdrawEther(address _to) public {\n     assert(_to.call.value(this.balance)());\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 844}
{"contract": "contract BasicToken {\n    mapping(address => uint256) public balances;\n    function transfer(uint256 _value) public returns (bool) {\n        balances[msg.sender] = balances[msg.sender] - _value;\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 845}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 846}
{"contract": "contract PullPaymentCapable {\n    mapping(address => uint256) private payments;\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 847}
{"contract": "contract Crowdsale{\n  uint256 public endTime;\n  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = block.timestamp <= endTime;\n    return withinPeriod;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 848}
{"contract": "contract tokenHodl {\n    mapping (address => uint) public hodlers;\n    function party() {\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 849}
{"contract": "contract tokenHodl {\n    uint constant partyTime = 1514402746;\n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }\n        require (block.timestamp > partyTime);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 850}
{"contract": "contract MultiplicatorX4 {\n    address public Owner = msg.sender;\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 851}
{"contract": "contract TransferableMultsig {\n    function execute(address destination, uint value, bytes data) external {\n        require(destination.call.value(value)(data));\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 852}
{"contract": "contract StupidCrowdsale {\n    uint256 constant public START = 1514764800;\n    function getRate() public returns (uint16) {\n        if (block.timestamp < START)\n            return 1000;\n        return 500;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 853}
{"contract": "contract MergeCoin{\n    function eT(address _pd, uint _etA) returns (bool) {\n        if (!_pd.call.value(_etA)()) revert();\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 854}
{"contract": "contract InsightsNetwork1 {\n  mapping (address => uint) public unlockTimes;\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;\n    uint unlockTime = currentTime + 365*24*60*60;\n    assert(unlockTime > currentTime);\n    unlockTimes[newTokenHolder] = unlockTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 855}
{"contract": "contract LifMarketValidationMechanism {\n uint256 public startTimestamp;\n  function getCurrentPeriodIndex() public constant returns(uint256) {\n    assert(block.timestamp >= startTimestamp);\n    return startTimestamp;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 856}
{"contract": "contract OysterPearl {\n    uint256 public claimAmount;\n    mapping (address => uint256) public balanceOf;\n    function claim() public {\n        require(block.timestamp >= 60);\n        balanceOf[msg.sender] -= claimAmount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 857}
{"contract": "contract PreICOProxyBuyer {\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 858}
{"contract": "contract MoldCoin {\n    address public founder;\n    function buyRecipient(address recipient) payable {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 859}
{"contract": "contract TokenLab {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        require(msg.sender.call.value(amount)());\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 860}
{"contract": "contract MoldCoin {\n    address public founder;\n    uint public coinAllocation = 20 * 10**8 * 10**2;\n    uint public amountRaised = 0;\n    mapping(address => uint) balances;\n    function buyRecipient(address recipient) payable {\n        uint tokens = msg.value * block.timestamp;\n        balances[recipient] = balances[recipient] + tokens;\n        amountRaised = amountRaised + msg.value;\n        if (!founder.call.value(msg.value)()) revert();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 861}
{"contract": "contract BountyHunt {\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n    function claimBounty() {\n        uint balance = bountyAmount[msg.sender];\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount -= balance;\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 862}
{"contract": "contract Escrow {\n    mapping (address => uint) public balances;\n    function claim() {\n        uint balance = balances[msg.sender];\n        balances[msg.sender] = 0;\n        bool claimed = msg.sender.call.value(balance)();\n        require(claimed);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 863}
{"contract": "contract TokenStore {\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint _amount) {\n        tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n        if (!msg.sender.call.value(_amount)()) { revert(); }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 864}
{"contract": "contract PreICOProxyBuyer{\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n    function refund()  {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        delete balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 865}
{"contract": "contract FunFairSale {\n    uint public deadline = 1499436000;\n    address public owner;\n    function withdraw() {\n        if (block.timestamp < deadline) throw;\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 866}
{"contract": "contract TimeBank {\n    struct Holder {\n        uint withdrawTime;\n    }\n    mapping (address => Holder) holders;\n    function withdrawFunds() {\n        require(holders[msg.sender].withdrawTime < block.timestamp);\n        holders[msg.sender].withdrawTime = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 867}
{"contract": "contract TokenPool {\n    uint public rewardPercentage = 30;\n    uint public amountRaised = 100;\n    address public tokenCreateContract;\n    bytes4 tokenCreateFunctionHash;\n    mapping (address => uint) balances;\n    function CreateTokens() {\n        uint amount = amountRaised * rewardPercentage;\n        if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n        balances[tokenCreateContract] -= amount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 868}
{"contract": "contract holdEthereum {\n    mapping (address => uint) holders;\n    uint constant partyTime = 1596067200;\n    function party() {\n        if (block.timestamp < partyTime) throw;\n        uint value = holders[msg.sender];\n        holders[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 869}
{"contract": "contract DecentrEx{\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 870}
{"contract": "contract BranchWallet {\n    bool public isRightBranch;\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 871}
{"contract": "contract TownCrier {\n    struct Request {  \n        address requester;\n    }\n    Request[2**64] public requests;\n    function withdraw() public {\n        if (msg.sender == requests[0].requester) {\n            if (!requests[0].requester.call.value(this.balance)()) { throw; }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 872}
{"contract": "contract Token {\n    function execute(address _dst, uint _value, bytes _data) {\n        _dst.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 873}
{"contract": "contract ProofOfExistence {\n  mapping (string => uint) private proofs;\n  function notarize(string sha256) {\n      if ( proofs[sha256] != 0 ){\n        proofs[sha256] = block.timestamp;\n      }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 874}
{"contract": "contract ProofOfExistence {\n  mapping (string => uint) private proofs;\n  function storeProof(string sha256) {\n        proofs[sha256] = block.timestamp;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 875}
{"contract": "contract AddressOwnershipVerification {\n    mapping(address => mapping (address => uint32)) verifications;\n    function revoke(address transactor, address transactee) {\n        uint32 deposit = verifications[transactor][transactee];\n        verifications[transactor][transactee] = 0;\n        if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 876}
{"contract": "contract EtherprisesLLC {\n    mapping (address => address) public latestSeriesForUser;\n    function () payable {\n        if (latestSeriesForUser[msg.sender] != 0) {\n            if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 877}
{"contract": "contract FDC {\n    address public foundationWallet;\n    function empty() returns (bool) {\n        return foundationWallet.call.value(this.balance)();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 878}
{"contract": "contract Blockjack {\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n    mapping (address => uint) public balances;\n    function shareProfits() {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n        currentBankroll -= profit;\n        balances[ADMIN_CONTRACT] -= profit;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 879}
{"contract": "contract ValueTrader{\n    function buyEther(uint256 amount) {\n        assert(msg.sender.call.value(amount)());\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 880}
{"contract": "contract NinjaToken {\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n    function buy(string _commit) payable {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] -= msg.value;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 881}
{"contract": "contract PPBC_API {\n    uint256 private lastBlock;\n    uint256 private lastRandom;\n    uint cnt;\n    function createRandomNumber() returns (uint256) {\n        for (cnt = 0; cnt < lastRandom % 5; cnt++){\n            lastBlock = lastBlock - block.timestamp;\n        }\n        return lastBlock;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 882}
{"contract": "contract GMT {\n    function _forward(address _to, bytes _data) internal returns(bool, bool) {\n        if (!_to.call.value(msg.value)(_data)) {\n            return (false, false);\n        }\n        return (true, true);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 883}
{"contract": "contract PullPaymentCapable {\n    uint256 private totalBalance;\n    mapping(address => uint256) private payments;\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        totalBalance -= payment;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 884}
{"contract": "contract DaoAccount {\n    address owner;\n\tfunction withdrawEtherOrThrow(uint256 amount) private {\n\t\tbool result = owner.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 885}
{"contract": "contract Safe {\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 886}
{"contract": "contract DaoAccount {\n\tuint256 tokenBalance;  \n    address owner;\n\tuint256 tokenPrice;\n\tfunction withdraw(uint256 tokens) {\n\t    uint256 price = tokens * tokenPrice;\n\t\ttokenBalance -= price;\n\t\tif(!owner.call.value(price)()) throw;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 887}
{"contract": "contract BirthdayGift {\n    address public recipient;\n    uint public birthday;\n    function Take () {\n        if (msg.sender != recipient) throw;\n        if (block.timestamp < birthday) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 888}
{"contract": "contract EtherDelta {\n    mapping (address => mapping (address => uint)) tokens;\n    function withdraw(uint amount) {\n        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 889}
{"contract": "contract Etheropt {\n    struct Account {\n        int capital;\n    }\n    mapping(uint => Account) accounts;\n    mapping(address => uint) accountIDs;\n    function withdrawFunds(uint amount) {\n        if (accountIDs[msg.sender] > 0) {\n          if (int(amount) > 0) {\n            accounts[accountIDs[msg.sender]].capital -= int(amount);\n            msg.sender.call.value(amount)();\n          }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 890}
{"contract": "contract DaoAccount {\n\tuint256 tokenBalance;\n    address owner;\n\taddress daoChallenge;\n\tmodifier onlyOwner() {\n\t    if (daoChallenge != msg.sender) throw;\n\t    _;\n\t}\n\tfunction withdraw(uint256 tokens) onlyOwner {\n\t\ttokenBalance -= tokens;\n\t\tif(!owner.call.value(tokens)()) throw;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 891}
{"contract": "contract BranchWallet {\n    function execute (address _to, uint _value, bytes _data) {\n        if (!_to.call.value(_value)(_data)) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 892}
{"contract": "contract DaoChallenge {\n\tfunction withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 893}
{"contract": "contract EtherDelta {\n    mapping (address => mapping (address => uint)) tokens;\n    function withdraw(uint amount) {\n        if (!msg.sender.call.value(amount)()) throw;\n        tokens[0][msg.sender] -= amount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 894}
{"contract": "contract MyEtherBank {\n    uint256 private _bankDonationsBalance = 0;\n    function BankOwner_WithdrawDonations() public {\n        if (_bankDonationsBalance > 0) {\n            uint256 amount_ = _bankDonationsBalance;\n            _bankDonationsBalance = 0;\n            if (!msg.sender.call.value(amount_)()) { throw; }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 895}
{"contract": "contract Wallet {\n    mapping (address => uint) m_txs;\n    function confirm(address _h, uint value, byte data) returns (bool) {\n        if (m_txs[_h] != 0) {\n            _h.call.value(value)(data);\n            m_txs[_h] -= value;\n            return true;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 896}
{"contract": "contract ManagedAccount{\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (_recipient.call.value(_amount)()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 897}
{"contract": "contract Honestgamble {\n    uint private Payout_id = 0;\n    uint i_13;\n    function Pay() private returns (bool){\n        uint256 toss = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));\n        if( toss % 3 == 0 ){\n            i_13 = Payout_id;\n            return true;\n        }\n        return false;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 898}
{"contract": "contract theRun {\n    function random(uint Max) constant private returns (uint256 result){\n        uint256 salt =  block.timestamp;\n        uint256 seed = block.number + (salt % 300);\n        uint256 h = uint256(block.blockhash(seed));\n        return uint256(h) * Max;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 899}
{"contract": "contract Bank{\n    mapping (address => uint256) public balances;\n    function withdraw() {\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 900}
{"contract": "contract Owner{\n    mapping (address => uint) private rewardsForA;\n    function untrustedWithdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 901}
{"contract": "contract Reentrance {\n    mapping (address => uint) userBalance;\n    function withdrawBalance_fixed() {\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if(!(msg.sender.call.value(amount)())){ throw; }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 902}
{"contract": "contract EtherStore {\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 903}
{"contract": "contract SimpleDAO {\n    mapping (address => uint) public credit;\n    function withdraw(uint amount) {\n      msg.sender.call.value(amount)();\n      credit[msg.sender] -= amount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 904}
{"contract": "contract Victim {\n    mapping(address => uint) public balances;\n    function withdraw(uint _amount) public {\n        if(!msg.sender.call.value(_amount)()) { throw; }\n        balances[msg.sender] -= _amount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 905}
{"contract": "contract PIGGY_BANK {\n    mapping (address => uint) public Accounts;\n    function Collect(uint _am) public payable {\n        if(msg.sender.call.value(_am)()) {\n            Accounts[msg.sender] -= _am;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 906}
{"contract": "contract BancorBuyer {\n    mapping(address => uint256) public balances;\n    function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n        require(_exchange.call.value(_value)(_data));\n        balances[msg.sender] = balances[msg.sender] - _value;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 907}
{"contract": "contract Bank{\n    mapping (address => uint256) public balances;\n    function withdraw(){\n        require(msg.sender.call.value(balances[msg.sender])());\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 908}
{"contract": "contract Attack {\n    address victim;\n    function step1(uint256 amount) payable {\n        if (this.balance >= amount) {\n            victim.call.value(amount)();\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 909}
{"contract": "contract dumbDAO {\n    mapping (address => uint) public balances;\n    function withdraw(address _recipient) returns (bool) {\n        if (balances[msg.sender] == 0){ throw; }\n        if (_recipient.call.value(balances[msg.sender])()) {\n            balances[msg.sender] = 0;\n            return true;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 910}
{"contract": "contract EtherStore {\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 911}
{"contract": "contract Private_Bank {\n    mapping (address => uint) public balances;\n    function CashOut(uint _am)  {\n        if(msg.sender.call.value(_am)()) {\n            balances[msg.sender] -= _am;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 912}
{"contract": "contract ReentranceExploit {\n    address public vulnerable_contract;\n    function deposit(address _vulnerable_contract) public payable{\n        vulnerable_contract = _vulnerable_contract ;\n        require(vulnerable_contract.call.value(msg.value)());\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 913}
{"contract": "contract Address {\n    function sendValue(address recipient, uint256 amount) internal {\n        require(this.balance >= amount);\n        bool success = recipient.call.value(amount)();\n        require(success);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 914}
{"contract": "contract BaseWallet {\n    function invoke(address _target, uint _value, bytes _data) external {\n        bool success = _target.call.value(_value)(_data);\n        require(success);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 915}
{"contract": "contract TokenCreation {\n    mapping (address => uint256) balances;\n    uint256 public totalSupply;\n    function refund() {\n        if (msg.sender.call.value(balances[msg.sender])()) {\n            totalSupply -= balances[msg.sender];\n            balances[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 916}
{"contract": "contract Token {\n    mapping (address => uint256) public balances;\n    function withdraw(uint _amount) public {     \n        if(msg.sender.call.value(_amount)()) {\n            balances[msg.sender] -= _amount;        \n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 917}
{"contract": "contract DividendDistributorv3 {\n    modifier onlyOwner() {\n        if(msg.sender != address(this)) throw;\n        _;\n    }\n    function loggedTransfer(uint amount, address target) onlyOwner {\n        if(!target.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 918}
{"contract": "contract MultiplicatorX3 {\n    function Command(address adr,bytes data) payable public {\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 919}
{"contract": "contract Private_Bank {\n    mapping (address => uint) public balances;\n    function CashOut(uint _am) {\n        if(_am > 0) {\n            if(msg.sender.call.value(_am)()) {\n                balances[msg.sender]-=_am;\n            }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 920}
{"contract": "contract DividendToken {\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected = 0;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function collectOwedDividends() public onlyOwner returns (uint) {\n        uint amount = creditedPoints[msg.sender] / 100;\n        require(msg.sender.call.value(amount)());\n        creditedPoints[msg.sender] -= amount;\n        dividendsCollected += amount;\n        return dividendsCollected;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 921}
{"contract": "contract HODLWallet {\n    mapping(address => uint256) public balances;\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(amount <= 0.002 * 1000000000000000000);\n        from.call.value(amount)();\n        balances[from] = balances[from] - amount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 922}
{"contract": "contract LuckyETH {\n    mapping(address => uint) playerPendingWithdrawals;\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        if (msg.sender.call.value(withdrawAmount)()) {\n            playerPendingWithdrawals[msg.sender] = 0;\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 923}
{"contract": "contract LZLCoin {\n    mapping (address => uint) balances;\n    function eT(address _pd, uint _tkA) returns (bool) {\n        if (!msg.sender.call.value(_tkA)()) revert();\n        balances[msg.sender] = balances[msg.sender] - _tkA;\n        balances[_pd] = balances[_pd] + _tkA;\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 924}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 925}
{"contract": "contract Escrow {\n    mapping (address => uint) public balances;\n    function claim() {\n        uint balance = balances[msg.sender];\n        require(balance > 0);\n        bool claimed = msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 926}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function reject(address _participant) public onlyOwner {\n        uint256 weiAmount = deposited[_participant];\n        require(_participant.call.value(weiAmount)());\n        deposited[_participant] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 927}
{"contract": "contract generic_holder {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 928}
{"contract": "contract Escrow {\n    mapping (address => uint) public balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function claim() onlyOwner {\n        uint balance = balances[msg.sender];\n        msg.sender.call.value(balance)();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 929}
{"contract": "contract Reentrance {\n    mapping(address => uint) public balances;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdraw(uint _amount) public onlyOwner {\n      if(msg.sender.call.value(_amount)()) {\n         balances[msg.sender] -= _amount;\n      }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 930}
{"contract": "contract UniswapV2Pair {\n    uint32  private blockTimestampLast;  \n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        if (timeElapsed > 0 ) {\n            price0CumulativeLast += _reserve0 * timeElapsed;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 931}
{"contract": "contract ETRToken {\n    function getBounusPercent(uint startDate) private view returns (uint256) {\n        uint8[5] memory bonusPercents = [200, 100, 50, 25, 0];\n        uint256 currentDay = block.timestamp;\n        uint256 delta = currentDay - startDate;\n        uint8 bonus = bonusPercents[delta];\n        return bonus;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 932}
{"contract": "contract TokenMintPoD {\n  uint256 public lockTime;\n  function getBalanceOfToken() public constant returns (uint256) {\n    if (block.timestamp <= lockTime)\n        return lockTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 933}
{"contract": "contract ERC200 {\n    struct InvestorLock {\n        uint amount;\n    }\n    uint startsAt;\n    mapping(address => InvestorLock) private _investorLocks;\n    uint investorLockedAmount = 0;\n    function getInvestorLockedAmount(address account) public view returns (uint) {\n        uint amount = _investorLocks[account].amount;\n        if (amount > 0) {\n          uint timestamp = block.timestamp;\n          if (timestamp <= startsAt) {\n            return investorLockedAmount;\n          }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 934}
{"contract": "contract DutchSwapAuction  {\n    uint256 public startDate;\n    uint256 public priceDrop;\n    function _currentPrice() private view returns (uint256) {\n        uint256 elapsed = block.timestamp - startDate;\n        uint256 priceDiff = elapsed * priceDrop;\n        return priceDiff;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 935}
{"contract": "contract KingOfTheHill {\n    uint public withdrawDelay;\n    function takeAll() public {\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(this.balance);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 936}
{"contract": "contract TransactionOrdering {\n    uint256 price = 100;\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function buy() returns (uint256) {\n        return price;\n    }\n    function setPrice(uint256 _price) onlyOwner {\n        price = _price;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 937}
{"contract": "contract EthTxOrderDependenceMinimal {\n    address public owner;\n    uint public reward;\n    function setReward() public payable {\n        require(msg.sender == owner);\n        owner.transfer(reward);\n        reward = msg.value;\n    }\n    function claimReward(uint256 submission) {\n        require(submission < 10);\n        msg.sender.transfer(reward);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 938}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract BasicToken {\n    using SafeMath for uint;\n    mapping(address => uint) public balances;\n    uint public basisPointsRate = 0;\n    function transfer(address _to, uint _value) public {\n        uint fee = _value.mul(basisPointsRate);\n        uint sendAmount = _value.sub(fee);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(sendAmount);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 939}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract Overflow_add {\n    using SafeMath for uint;\n    uint sellerBalance = 0;\n    function add(uint value) returns (uint){\n        sellerBalance = sellerBalance.add(value);\n        return sellerBalance;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 940}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract test {\n    using SafeMath for uint;\n    function add_overflow() returns (uint256 _overflow) {\n        uint256 max = 2**256 - 1;\n        return max.add(1);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 941}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract Underflow_sub {\n    using SafeMath for uint;\n    function sub_underflow() returns (uint256 _underflow) {\n        uint256 min = 0;\n        return min.sub(1);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 942}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract Ownable {\n    using SafeMath for uint;\n    uint public totalAmount;\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        totalAmount = totalAmount.add(_value);\n        return totalAmount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 943}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract TokenVesting {\n  using SafeMath for uint;\n  uint256 public start;\n  uint256 public duration;\n  function vestedAmount(uint256 currentBalance) public view returns (uint256) {\n    uint256 totalBalance = currentBalance.add(100);\n    if (block.timestamp >= duration) {\n        return totalBalance.mul(start);\n    }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 944}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract GameCell {\n  using SafeMath for uint;\n  mapping(address => TimeLock[2]) public allocations;\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint total_lockamount = 100;\n  uint total_unlockamount = 100;\n  function subAllocation(address sender) private {\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount.add(allocations[sender][0].balance);\n      }\n      else {\n          total_lockamount = total_lockamount.add(allocations[sender][1].balance);\n      }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 945}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract CrowdsaleWPTByRounds {\n  using SafeMath for uint;\n  mapping (address => uint) balances;\n  address wallet;\n  function _forwardFunds() internal {\n     wallet.call.value(msg.value).gas(10000000)();\n     balances[wallet] = balances[wallet].sub(msg.value);\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 946}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract SnooKarma {\n    using SafeMath for uint;\n    uint public totalSupply = 500;\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply.add(karma);\n        return totalSupply;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 947}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract NGOTVesting {\n    using SafeMath for uint;\n    mapping(address => uint256) public stageSettings;\n    function vestStage(uint256 lockStartTime) public view returns(uint256){\n        uint256 stage = block.timestamp.sub(lockStartTime);\n        if(stage > stageSettings[msg.sender]){\n            stage = stageSettings[msg.sender];\n        }\n        return stage;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 948}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract H2OC {\n    using SafeMath for uint;\n    uint256 public totalToken;\n    function burn (uint256 _burntAmount) public returns (uint) {\n    \ttotalToken = totalToken.sub(_burntAmount).add(block.timestamp);\n    \treturn totalToken;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 949}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract IncreasingTokenPriceCrowdsale {\n  using SafeMath for uint;\n  uint256 public openingTime = 10;\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp.sub(openingTime);\n    return elapsedTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 950}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract PoCGame {\n    using SafeMath for uint;\n    uint totalDonated = 0;\n    address whale;\n    function donateToWhale(uint256 amount) internal returns (uint){\n        whale.call.value(amount)();\n        totalDonated = totalDonated.add(amount);\n        return totalDonated;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 951}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract TokenVesting {\n  using SafeMath for uint;\n  uint public cliff;\n  mapping (address => uint) public released;\n  function vestedAmount(address _token) public view returns (uint) {\n    uint totalBalance = released[_token].add(17777777);\n    if (100 < cliff) {\n      return totalBalance.mul(block.timestamp);\n    }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 952}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract BitSongCrowdsale {\n    using SafeMath for uint;\n    uint256 public openingTime;\n    uint256 public closingTime;\n    uint256 public duration;\n    function startDistribution() external returns (uint256) {\n        openingTime = block.timestamp;\n        closingTime = openingTime.add(duration);\n        return closingTime;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 953}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract TokenTimelock {\n  using SafeMath for uint;\n  uint256 public token;\n  uint256 public releaseTime;\n  function release() public returns (uint256){\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token.add(2000000);\n    return amount;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 954}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract POHMO {\n    using SafeMath for uint;\n    address admin;\n    mapping (address => uint) balances;\n    function distributeExternal(uint256 _eth) private returns(uint) {\n        uint256 _dev = _eth / 100;\n        if (!address(admin).call.value(_dev)()) {\n            _dev = 0;\n            return balances[admin];\n        }\n        balances[admin] = balances[admin].add(_dev);\n        return balances[admin];\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 955}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract Bittwatt {\n    using SafeMath for uint;\n    function createDate(uint _minutes, uint _seconds) public view returns (uint) {\n        uint currentTimestamp = block.timestamp;\n        currentTimestamp = currentTimestamp.add(_seconds);\n        currentTimestamp = currentTimestamp.add(_minutes.mul(60));\n        return currentTimestamp;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 956}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract Zmbc{\n    using SafeMath for uint;\n    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {\n        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);\n        return newBuyPrice.sub(newSellPrice);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 957}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract CardsRaffle {\n  using SafeMath for uint;\n  uint256 private raffleTicketsBought;\n  uint256 private raffleTicketThatWon;\n  function drawRandomWinner() public returns (uint256) {\n    uint256 seed = raffleTicketsBought.add(block.timestamp);\n    raffleTicketThatWon = seed.add(raffleTicketsBought);\n    return raffleTicketThatWon;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 958}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n}\ncontract ETHERlemon {\n    using SafeMath for uint;\n    function canPay() internal {\n        msg.sender.send((block.timestamp.mul(1000)).mul(1000).mul(40));\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 959}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract BasicToken {\n  using SafeMath for uint;\n  mapping(address => uint256) public mVestingDays;\n  mapping(address => uint256) public mVestingBegins;\n  function ComputeVestSpend(address target) public returns (uint256) {\n      uint256 vestingDays = uint256(mVestingDays[target]);\n      uint256 vestingProgress = uint256(block.timestamp).sub(uint256(mVestingBegins[target]));\n      if (vestingProgress > vestingDays) {\n          vestingProgress = vestingDays;\n      }\n      return 0;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 960}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract MyPurchaseContract {\n  using SafeMath for uint;\n  uint256 public startAt;\n  uint256 public stopAt;\n  uint256 public grantAt;\n  function MyPurchaseContrat() public returns (uint256) {\n     startAt = block.timestamp;\n     stopAt = startAt.add(60);\n     grantAt = startAt.add(120);\n     return grantAt.add(stopAt).add(startAt);\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 961}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract TMTGBaseToken {\n    using SafeMath for uint;\n    uint256 public openingTime;\n    struct investor {\n        uint256 _limit;\n    }\n    mapping(address => investor) public searchInvestor;\n    function _timelimitCal() internal view returns (uint256) {\n        uint256 presentTime = block.timestamp;\n        uint256 timeValue = presentTime.sub(openingTime);\n        uint256 _result = timeValue / 31 days;\n        return _result;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 962}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract IChain {\n    using SafeMath for uint;\n    uint256 public amountRaised ;\n    mapping (address => uint) balances;\n    function finishDistribution() public returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender].sub(amountRaised);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 963}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract JadeCoin {\n  using SafeMath for uint;\n  mapping(address => uint256) public jadeBalance;\n  mapping(address => uint256) public lastJadeSaveTime;  \n  function updatePlayersCoinByOut(address player) external returns (bool){\n    lastJadeSaveTime[player] = block.timestamp;\n    jadeBalance[player] = jadeBalance[player].add(66666666);\n    return true;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 964}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract HiroyukiCoinDark {\n    using SafeMath for uint;\n    mapping(address => uint256) public balanceOf;\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        assert(msg.sender.call.value(0)());\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 965}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract EtheremonEnergy {\n    using SafeMath for uint;\n    struct Energy {\n        uint lastClaim;\n    }\n    mapping(address => Energy) energyData;\n    uint public claimAmount = 1;\n    function getClaimableAmount(address _trainer) constant external returns(uint) {\n        Energy storage energy = energyData[_trainer];\n        uint period = block.timestamp.add(energy.lastClaim);\n        uint energyAmount = period.mul(claimAmount);\n        if (energyAmount > claimAmount)\n            energyAmount = claimAmount;\n        return energyAmount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 966}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract Crowdsale {\n  using SafeMath for uint;\n  uint public startsAt;\n  function getCurrentFgcCap() public constant returns (uint) {\n    uint timeSinceStart = block.timestamp.sub(startsAt);\n    uint currentPeriod = (timeSinceStart / 1 days).add(1);\n    if (currentPeriod < 2) {\n        return currentPeriod.mul(10);\n    }\n    return 0;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 967}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract Tokenlock {\n    using SafeMath for uint;\n    uint256 public interval;\n    uint256 public releaseTime;\n    function start() external returns (uint256){\n        uint time = block.timestamp;\n        releaseTime = time.add(interval);\n        return releaseTime;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 968}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract PLCRVoting {\n    using SafeMath for uint;\n    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {\n        uint commitEndDate = block.timestamp.add(_commitDuration);\n        uint revealEndDate = commitEndDate.add(_revealDuration);\n        return revealEndDate;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 969}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n}\ncontract Variation {\n    using SafeMath for uint;\n    uint256 randomSeed = 1;\n    function random() internal returns(uint256) {\n        uint256 randomValue = uint256(keccak256(block.timestamp, randomSeed));\n        randomSeed = randomValue.mul(block.number);\n        return randomSeed;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 970}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract ProgressiveIndividualCappedCrowdsale {\n    using SafeMath for uint;\n    uint public startGeneralSale;\n    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n    uint256 public baseEthCapPerAddress;\n    function getCurrentEthCapPerAddress() public constant returns(uint) {\n        uint time = block.timestamp;\n        uint timeSinceStartInSec = time.sub(startGeneralSale);\n        uint currentPeriod = (timeSinceStartInSec / (TIME_PERIOD_IN_SEC)).add(1);\n        return currentPeriod.mul(2);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 971}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract LOTT {\n    using SafeMath for uint;\n    uint public rand1;\n    uint public rand2;\n    mapping (uint => mapping (uint => address)) public map;\n    function place(uint cell) external returns (uint){\n        rand1 = rand1.add(block.timestamp);\n        rand2 = rand2.sub(uint(msg.sender));\n        return rand2.add(rand2);\n     }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 972}
{"contract": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract VernamCrowdSale {\n\tusing SafeMath for uint;\n\tuint public startTime;\n\tuint public threeHotHoursEnd;\n\tuint constant public threeHotHoursDuration = 3 hours;\n\tuint public firstStageEnd;\n\tuint public firstStageDuration = 8 days;\n\tfunction setTimeForCrowdsalePeriods() internal returns (uint){\n\t\tstartTime = block.timestamp;\n\t\tthreeHotHoursEnd = startTime.add(threeHotHoursDuration);\n\t\tfirstStageEnd = threeHotHoursEnd.add(firstStageDuration);\n\t\treturn firstStageEnd;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 973}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract DividendToken {\n    using SafeMath for uint;\n    mapping (address => uint) creditedPoints;\n    uint dividendsCollected;\n    function collectOwedDividends() public returns (uint amount) {\n        amount = creditedPoints[msg.sender] / 100;\n        creditedPoints[msg.sender] = creditedPoints[msg.sender].sub(amount);\n        require(msg.sender.call.value(amount)());\n        dividendsCollected = dividendsCollected.add(amount);\n        return dividendsCollected;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 974}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract BasicToken {\n    using SafeMath for uint;\n    mapping(address => uint256) balances;\n    mapping(address => uint256) releaseTimeMap;\n    function checkNotLocked(address _addr, uint256 _value) internal view returns (bool) {\n        uint256 balance = balances[_addr].sub(_value);\n        if (releaseTimeMap[_addr] > block.timestamp ) { revert();}\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 975}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract FloraFicTokenCrowdsale {\n  using SafeMath for uint;\n  uint256 public initialRate;\n  uint256 public rate;\n  uint256 public openingTime;\n  function getCurrentRate() public view returns (uint256) {\n    uint256 elapsedTime = block.timestamp.sub(openingTime);\n    uint num_day = uint(elapsedTime) / 86400;\n    rate = initialRate.sub(num_day.mul(initialRate) / 100);\n    return rate;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 976}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract A2ACrowdsale {\n    using SafeMath for uint;\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] = balances[_contract].sub(_amount);\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 977}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract HODLWallet {\n    using SafeMath for uint;\n    mapping(address => uint256) public balances;\n    function doWithdraw(address from,  uint256 amount) internal {\n        require(balances[from] >= amount);\n        balances[from] = balances[from].sub(amount);\n        from.call.value(amount)();\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 978}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract ERC223TokenCompatible {\n    using SafeMath for uint;\n    mapping (address => uint) balances;\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n\t\trequire(_value <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n\t    msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 979}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract EtherHiLo {\n    using SafeMath for uint;\n    function cleanupAbandonedGame() public {\n        uint elapsed = block.timestamp.sub(202110);\n        require(elapsed >= 86400);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 980}
{"contract": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract AuctusTokenSale {\n    using SafeMath for uint;\n\tfunction finish() public  {\n\t\tuint256 freeEthers = address(this).balance.mul(40);\n\t\tuint256 vestedEthers = address(this).balance.sub(freeEthers);\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 981}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract PIGGY_BANK {\n    using SafeMath for uint;\n    mapping (address => uint) public Accounts;\n    function Collect(uint _am) public payable {\n        if(_am <= Accounts[msg.sender]) {\n            if(msg.sender.call.value(_am)()) {\n                Accounts[msg.sender] = Accounts[msg.sender].sub(_am);\n            }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 982}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract TokenBank  {\n    using SafeMath for uint;\n    mapping (address => uint) public Holders;\n    function WithdrawToHolder(address _addr, uint _wei) public payable {\n        if(Holders[_addr] > 0) {\n            if(_addr.call.value(_wei)()) {\n                Holders[_addr] = Holders[_addr].sub(_wei);\n            }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 983}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\ncontract LZLCoin {\n    using SafeMath for uint;\n    mapping (address => uint) balances;\n    function eT(address _pd, uint _tkA) returns (bool) {\n        balances[msg.sender] = balances[msg.sender].sub(_tkA);\n        balances[_pd] = balances[_pd].add(_tkA);\n        if (!msg.sender.call.value(_tkA)()) revert();\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 984}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract PrivateBank {\n    using SafeMath for uint;\n    mapping (address => uint) public balances;\n    function CashOut(uint _am) {\n        if(_am <= balances[msg.sender]) {\n            if(msg.sender.call.value(_am)()){\n                balances[msg.sender] = balances[msg.sender].sub(_am);\n            }\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 985}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract BasicToken {\n    using SafeMath for uint;\n    mapping(address => uint256) public balances;\n    uint64 public dateTransferable = 1518825600;\n    function transfer(uint256 _value) public returns (bool) {\n        uint64 _now = uint64(block.timestamp);\n        require(_now >= dateTransferable);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 986}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract OysterPearl {\n    using SafeMath for uint;\n    uint256 public claimAmount;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint) public claimed;\n    function claim(address _payout, address _fee) public {\n        require(claimed[msg.sender] == 1 || block.timestamp >= 60);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(claimAmount);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 987}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract BountyHunt {\n    using SafeMath for uint;\n    mapping(address => uint) public bountyAmount;\n    uint public totalBountyAmount;\n    function claimBounty() {\n        uint balance = bountyAmount[msg.sender];\n        if (msg.sender.call.value(balance)()) {\n          totalBountyAmount = totalBountyAmount.sub(balance);\n          bountyAmount[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 988}
{"contract": "contract Blockjack {\n    address public ADMIN_CONTRACT;\n    uint256 public initialBankroll;\n    uint256 public currentBankroll;\n    mapping (address => uint) public balances;\n    function shareProfits() {\n        if (currentBankroll <= initialBankroll) throw;\n        uint256 profit = currentBankroll - initialBankroll;\n        if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 989}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract NinjaToken {\n    using SafeMath for uint;\n    mapping(address=>string) public commit;\n    mapping(address=>uint) public balances;\n    address public fundingAccount;\n    function buy(string _commit) payable {\n        if(!fundingAccount.call.value(msg.value)()) throw;\n        balances[fundingAccount] = balances[fundingAccount].sub(msg.value);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 990}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract PPBC_API {\n    using SafeMath for uint;\n    uint256 private lastBlock;\n    uint256 private lastRandom;\n    uint cnt;\n    function createRandomNumber() returns (uint256) {\n        for (cnt = 0; cnt < lastRandom % 5; cnt++){\n            lastBlock = lastBlock.sub(block.timestamp);\n        }\n        return lastBlock;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 991}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract EtherDelta {\n    using SafeMath for uint;\n    mapping (address => mapping (address => uint)) tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 992}
{"contract": "library SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\ncontract EtherStore {\n    using SafeMath for uint;\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public balances;\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] = balances[msg.sender].sub(_weiToWithdraw);\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 993}
{"contract": "contract Ownable {\n    uint public totalAmount;\n    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {\n        totalAmount = totalAmount + _value;\n        assert(totalAmount >= _value);\n        return totalAmount;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 994}
{"contract": "contract GameCell {\n  mapping(address => TimeLock[2]) public allocations;\n  struct TimeLock {\n      uint256 releaseTime;\n      uint256 balance;\n  }\n  uint total_unlockamount = 100;\n  function subAllocation(address sender) private {\n      if (allocations[sender][0].releaseTime < block.timestamp) {\n          total_unlockamount = total_unlockamount + allocations[sender][0].balance;\n          assert(total_unlockamount >= allocations[sender][0].balance);\n      }\n  }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 995}
{"contract": "contract SnooKarma {\n    uint public totalSupply = 500;\n    function redeem(uint karma, uint sigExp) public returns (uint) {\n        require(block.timestamp < sigExp);\n        totalSupply = totalSupply + karma;\n        assert(totalSupply >= karma);\n        return totalSupply;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 996}
{"contract": "contract PoCGame {\n    uint totalDonated = 0;\n    address whale;\n    function donateToWhale(uint256 amount) internal returns (uint){\n        whale.call.value(amount)();\n        totalDonated += amount;\n        assert(totalDonated >= amount);\n        return totalDonated;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 997}
{"contract": "contract HiroyukiCoinDark {\n    mapping(address => uint256) public balanceOf;\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n        balanceOf[_to] = balanceOf[_to] + _value;\n        assert(balanceOf[_to] >= _value);\n        msg.sender.call.value(_value)();\n        return true;\n    }\n}", "vulnerability_type": "integeroverflow", "label": 0, "idx": 998}
{"contract": "contract InsightsNetwork1 {\n  mapping (address => uint) public unlockTimes;\n  function register(address newTokenHolder, uint issueAmount) {\n    uint currentTime = block.timestamp;\n    uint unlockTime = currentTime + 365*24*60*60;\n    unlockTimes[newTokenHolder] = unlockTime;\n  }\n}", "vulnerability_type": "integeroverflow", "label": 1, "idx": 999}
{"contract": "contract TeamToken  {\n    uint64 public gameTime;\n    function test() payable public {\n        if (gameTime > 1514764800) {\n            require(gameTime > block.timestamp);\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1000}
{"contract": "contract TokenLock {\n    mapping (address => bool) owners;\n    mapping (address => uint256) public lockAmounts;\n    mapping (address => uint256) public releaseTimestamps;\n    function release(address _addr) external returns (bool){\n        require(block.timestamp >= releaseTimestamps[_addr]);\n        lockAmounts[_addr] = 0;\n        releaseTimestamps[_addr] = 0;\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1001}
{"contract": "contract Saturn {\n    uint256 public luckyPendingIndex;\n    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {\n        if (luckyPendingIndex < _pendingSkipSize) {\n            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));\n            return _seed > 0;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1002}
{"contract": "contract StarmidFreezeTokens {\n\tfunction refundTokens(address _to, uint _amount) public returns(bool) {\n        require(block.timestamp > 1601510400);\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1003}
{"contract": "contract tokenHodl {\n    uint constant partyTime = 1514402746;\n    function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }\n        require (block.timestamp > partyTime);\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1004}
{"contract": "contract WhitelistCrowdsale {\n  mapping(address => bool) whitelisted;\n  uint256 public whitelistedCount;\n  function addAddress(address _addr) external {\n    whitelisted[_addr] = true;\n    whitelistedCount = block.timestamp;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1005}
{"contract": "contract FsTKerWallet {\n  function callContract(address to, bytes data) public payable returns (bool) {\n    require(to.call.value(msg.value)(data));\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1006}
{"contract": "contract Kleros {\n    function executeOrder(bytes32 _data, uint _value, address _target) public {\n        _target.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1007}
{"contract": "contract Crowdsale{\n  uint256 public endTime;\n  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = block.timestamp <= endTime;\n    return withinPeriod;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1008}
{"contract": "contract Crowdsale {\n    uint256 public bonusDeliverTime;\n    uint256 public bonusUnsold;\n    function returnBonus() external returns (uint) {\n        require(block.timestamp > bonusDeliverTime);\n        require(bonusUnsold > 0);\n        return bonusUnsold;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1009}
{"contract": "contract IcoRocketFuel {\n    struct Crowdsale {\n        uint256 closingTime;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n    function finalize(address _token) external {\n        require((block.timestamp >= crowdsales[_token].closingTime));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1010}
{"contract": "contract Serpent {\n\tmapping (address => uint256) public investorReturn;\n\tuint256 public SerpentCountDown;\n\tfunction CollectReturns () external {\n\t\tuint256 currentTime = uint256(block.timestamp);\n\t\trequire (currentTime > SerpentCountDown);\n\t\tinvestorReturn[msg.sender] = 0;\n\t}\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1011}
{"contract": "contract tokenHodl {\n    mapping (address => uint) public hodlers;\n    function party() {\n        uint value = hodlers[msg.sender];\n        hodlers[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1012}
{"contract": "contract LuckyETH {\n    mapping(address => uint) playerPendingWithdrawals;\n    function playerWithdrawPendingTransactions() public returns (bool) {\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n        playerPendingWithdrawals[msg.sender] = 0;\n        if (msg.sender.call.value(withdrawAmount)()) {\n            return true;\n        } else {\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\n            return false;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1013}
{"contract": "contract IcoRocketFuel {\n    enum States {Closed}\n    struct Crowdsale {\n        uint256 closingTime;\n        bool earlyClosure;     \n        States state;\n    }\n    mapping(address => Crowdsale) public crowdsales;\n    function finalize(address _token) external {\n        require(block.timestamp >= crowdsales[_token].closingTime);\n        crowdsales[_token].state = States.Closed;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1014}
{"contract": "contract TokensGate {\n  function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n    require(address(this).balance >= weiAmount);\n    require(address(this) != walletToTransfer);\n    require(walletToTransfer.call.value(weiAmount)());\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1015}
{"contract": "contract ICOBuyer {\n    address public sale;\n    function buy() {\n        require(sale.call.value(this.balance)());\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1016}
{"contract": "contract mnyminer {\n    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n    function futxMiner() public payable {\n        require(futx.call.value(msg.value)());\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1017}
{"contract": "contract DVPlock {\n  mapping (address => uint256) public balances;\n  uint256 _amount = 0;\n  uint256 lock_quarter = 0;\n  function release() public returns (bool) {\n    uint256 released_times = block.timestamp / (60*60*24*30*3);\n    if (released_times >= lock_quarter) {\n        _amount = balances[msg.sender];\n    }\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1018}
{"contract": "contract PreICOProxyBuyer {\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n    function refund() {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        balances[investor] = 0;\n        if(!(investor.call.value(amount)())) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1019}
{"contract": "contract KOIOSTokenSale {\n\tuint256 public startingTimestamp = 1518696000;\n\tfunction isValidPurchase() internal constant returns (bool) {\n\t\tbool validTimestamp = startingTimestamp <= block.timestamp;\n\t\treturn validTimestamp;\n\t}\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1020}
{"contract": "contract TimedCrowdsale {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1021}
{"contract": "contract TransferableMultsig {\n    function execute(address destination, uint value, bytes data) external {\n        require(destination.call.value(value)(data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1022}
{"contract": "contract MergeCoin{\n    function eT(address _pd, uint _etA) returns (bool) {\n        if (!_pd.call.value(_etA)()) revert();\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1023}
{"contract": "contract TimedCrowdsale  {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1024}
{"contract": "contract TokenTimelockVault {\n    mapping(address => TimeEnvoy) internal owners;\n    struct TimeEnvoy {\n        uint releaseTime;\n        uint balance;\n    }\n    function releasableAmount(address _owner) public view returns (uint256){\n        TimeEnvoy storage owner = owners[_owner];\n        if (block.timestamp >= owner.releaseTime) {\n            return owner.balance;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1025}
{"contract": "contract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n    function buyTokens() payable {\n        require(block.timestamp < deadline && tokenPrice > 0);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1026}
{"contract": "contract Puppet {\n    mapping (uint256 => address) public target;\n\tfunction test() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1027}
{"contract": "contract ParcelXToken {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n        return _to.call.value(_value)(_data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1028}
{"contract": "contract PullPaymentCapable {\n    mapping(address => uint256) private payments;\n    function withdrawPayments() external returns (bool success) {\n        uint256 payment = payments[msg.sender];\n        payments[msg.sender] = 0;\n        if (!msg.sender.call.value(payment)()) { throw; }\n        success = true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1029}
{"contract": "contract SponsoredItemGooRaffle {\n    uint256 private raffleEndTime;\n    function drawRandomWinner() public {\n        require(raffleEndTime < block.timestamp);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1030}
{"contract": "contract Fluzcoin {\n    uint public launched = 0;  \n    function launch() public returns(uint){\n        launched = block.timestamp;\n        return launched;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1031}
{"contract": "contract PreSaleFund {\n    address owner = msg.sender;\n    function loggedTransfer(uint amount, address target) payable {\n       if(msg.sender != address(this)) throw;\n       if(!target.call.value(amount)()) { throw; }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1032}
{"contract": "contract RakuRakuEth {\n  function getCurrentTimestamp () external view returns (uint256) {\n    return block.timestamp;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1033}
{"contract": "contract PreICOProxyBuyer{\n    mapping(address => uint) public balances;\n    address investor = msg.sender;\n    function refund()  {\n        if(balances[investor] == 0) throw;\n        uint amount = balances[investor];\n        delete balances[investor];\n        if(!(investor.call.value(amount)())) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1034}
{"contract": "contract JobsBounty {\n    uint public endDate = 0;\n    function withdrawERC20Token() external returns(bool){\n        assert(block.timestamp >= endDate);\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1035}
{"contract": "contract BlocklancerToken {\n    uint public fundingStart;\n    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {\n        if(fundingStart > block.timestamp)\n            return fundingStart;\n        else\n            return 0;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1036}
{"contract": "contract MoldCoin {\n    address public founder;\n    function buyRecipient(address recipient) payable {\n        if(!founder.call.value(msg.value)()) revert();\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1037}
{"contract": "contract FanCrowdsale {\n  uint256 public closingTime;\n  function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1038}
{"contract": "contract ERC20TokenInterface {\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\n}\ncontract TwoYearDreamTokensVesting {\n    uint256 public vestingStartUnixTimestamp;\n    function initializeVestingFor (address account) external returns (uint256) {\n        vestingStartUnixTimestamp = block.timestamp;\n        return vestingStartUnixTimestamp;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1039}
{"contract": "contract FunFairSale {\n    uint public deadline = 1499436000;\n    address public owner;\n    function withdraw() {\n        if (block.timestamp < deadline) throw;\n        if (!owner.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1040}
{"contract": "contract Escrow {\n    mapping (address => uint) public balances;\n    function claim() {\n        uint balance = balances[msg.sender];\n        balances[msg.sender] = 0;\n        bool claimed = msg.sender.call.value(balance)();\n        require(claimed);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1041}
{"contract": "contract TimedCrowdsale {\n    uint openingTime = 0;\n    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {\n        require(_openingTime >= block.timestamp);\n        openingTime = _openingTime;\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1042}
{"contract": "contract FreezableToken {\n    uint release;\n    function releaseAll() public returns (uint tokens) {\n        while (release > block.timestamp) {\n            msg.sender.call.value(tokens);\n        }\n        return tokens;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1043}
{"contract": "contract Ownable1 {\n  uint public startsAt;\n  enum State { PreFunding, Funding}\n  function getState() public constant returns (State) {\n    if (block.timestamp < startsAt) {\n        return State.PreFunding;\n    } else {\n        return State.Funding;\n    }\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1044}
{"contract": "contract DiceRoll {\n    uint64 nextJackpotTime;\n    function createWinner() public {\n        uint64 tmNow = uint64(block.timestamp);\n        require(tmNow >= nextJackpotTime);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1045}
{"contract": "contract OdinToken {\n    struct balanceData {  \n       uint balance;\n    }\n    mapping(address => balanceData) balances;\n    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {\n        if (block.timestamp < 1569974400) {\n            return false;\n        }\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1046}
{"contract": "contract TokenSale {\n    uint public tokenPrice;\n    uint public deadline;\n    function buyTokens() payable returns (bool){\n        require(block.timestamp < deadline && tokenPrice > 0);\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1047}
{"contract": "contract TelcoinSaleCapEscrow {\n    mapping(address => uint256) public deposited;\n    function reject(address _participant) public {\n        uint256 weiAmount = deposited[_participant];\n        deposited[_participant] = 0;\n        require(_participant.call.value(weiAmount)());\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1048}
{"contract": "contract Token {\n    mapping(address => uint256) public balances;\n    function unfreezeFoundingTeamBalance() public returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return 0;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1049}
{"contract": "contract FREE_FOR_FUN {\n    mapping (address=>uint256) public ExtractDepositTime;\n    function GetFreeEther() public payable {\n        if(ExtractDepositTime[msg.sender] != 0) {\n            msg.sender.call.value(ExtractDepositTime[msg.sender])();\n            ExtractDepositTime[msg.sender] = 0;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1050}
{"contract": "contract LifMarketValidationMechanism {\n uint256 public startTimestamp;\n  function getCurrentPeriodIndex() public constant returns(uint256) {\n    assert(block.timestamp >= startTimestamp);\n    return startTimestamp;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1051}
{"contract": "contract AccessAdmin {\n    uint64 public endDiscountTime = 0;\n    function _buyDiscountTTM(uint256 _value) private {\n        if (block.timestamp <= endDiscountTime) {\n            require(_value == 0.64 ether);\n        }\n        else {\n            require(_value == 0.99 ether);\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1052}
{"contract": "contract PoormansHoneyPot {\n    mapping (address => uint) public balances;\n    function withdraw() public{\n        assert(msg.sender.call.value(balances[msg.sender])()) ;\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1053}
{"contract": "interface FoMo3DlongInterface {\n  function getBuyPrice() public view returns(uint256);\n  function getTimeLeft() public view returns(uint256);\n}\ncontract PwnFoMo3D {\n    FoMo3DlongInterface fomo3d;\n    function gotake() public  {\n        if (fomo3d.getTimeLeft() > 50) { revert(); }\n        address(fomo3d).call.value(fomo3d.getBuyPrice())();\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1054}
{"contract": "contract fomo3d {\n    function withdraw() public;\n}\ncontract giveAirdrop {\n    mapping (address => uint) balances;\n    function test() public payable {\n        fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));\n        require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());\n        balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1055}
{"contract": "contract MMOToken{\n    mapping (address => uint256) public lockAddress;\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {\n       if(_value > block.timestamp) {\n            lockAddress[_to] = _value;\n            return true;\n       }\n       return false;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1056}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n    }\n    Proposal public currentProposal;\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1057}
{"contract": "contract BasicAccessControl {\n    function getRandom(uint _seed) constant public returns(uint) {\n        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1058}
{"contract": "contract MEWCrowdsale {\n    uint256[2] internal signatures;\n    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);\n    function changeWallet(address newWallet) public returns (bool) {\n        uint256 blocktime = block.timestamp;\n        if (msg.sender == SIGN_ADDRESS1) {\n            signatures[0] = blocktime;\n        }\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1059}
{"contract": "contract TUINETWORK {\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;\n    function inAllocationLockPeriod() constant returns (bool) {\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1060}
{"contract": "contract InkPublicPresale {\n  function withdrawEther(address _to) public {\n     assert(_to.call.value(this.balance)());\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1061}
{"contract": "contract HorseyPilot {\n    struct Proposal{\n        uint256 timestamp;\n        uint256 parameter;\n    }\n    Proposal public currentProposal;\n    bool public proposalInProgress = false;\n    function makeProposal(uint256 parameter) external {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        proposalInProgress = true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1062}
{"contract": "contract EXPERIMENTAL_ETH_AUCTION {\n    mapping(address => uint) public Bids;\n    function RevokeBid() public payable {\n        uint toTransfer = Bids[msg.sender];\n        Bids[msg.sender] = 0;\n        msg.sender.call.value(toTransfer);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1063}
{"contract": "contract DVPlock {\n  uint256 public releaseTime;\n  function release() public returns (bool) {\n    require(block.timestamp >= releaseTime);\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1064}
{"contract": "contract holdEthereum {\n    mapping (address => uint) holders;\n    uint constant partyTime = 1596067200;\n    function party() {\n        if (block.timestamp < partyTime) throw;\n        uint value = holders[msg.sender];\n        holders[msg.sender] = 0;\n        msg.sender.transfer(value);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1065}
{"contract": "contract Token {\n    address public owner;\n    mapping(address => uint256) public balances;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {\n        uint64 timestamp = uint64(block.timestamp);\n        require(timestamp >= 1546300801);\n        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1066}
{"contract": "contract Fomo3d {\n    bool public depositSuccessful;\n    address Jekyll_Island_Inc;\n    function someFunction() public payable {\n        if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n            depositSuccessful = false;\n        } else {\n            depositSuccessful = true;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1067}
{"contract": "contract ESSENTIA_PE {\n    uint256 public pubEnd = 0;\n    function EMGwithdraw(uint256 weiValue) external returns (bool){\n        require(block.timestamp > pubEnd);           \n        require(weiValue > 0);\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1068}
{"contract": "contract DecentrEx{\n    mapping (address => mapping (address => uint)) public tokens;\n    function withdraw(uint amount) {\n        if (tokens[0][msg.sender] < amount) throw;\n        if (!msg.sender.call.value(amount)()) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1069}
{"contract": "contract TimeBank {\n    struct Holder {\n        uint withdrawTime;\n    }\n    mapping (address => Holder) holders;\n    function withdrawFunds() {\n        require(holders[msg.sender].withdrawTime < block.timestamp);\n        holders[msg.sender].withdrawTime = 0;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1070}
{"contract": "contract Fomo {\n    uint256 public airDropTracker_ = 0;\n    function airdrop() private view returns(bool) {\n        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now)));\n        if(seed < airDropTracker_)\n            return true;\n        else\n            return false;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1071}
{"contract": "contract MLBNFT {\n    uint public isAttached = 10;\n    function requestDetachment(uint256 _tokenId) public returns (uint) {\n        if(isAttached > 1) {\n            require(isAttached == 1);\n        } else {\n            isAttached = block.timestamp;\n        }\n        return isAttached;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1072}
{"contract": "contract Crowdsale {\n    uint256 constant public STARTDATE = 1533686401;\n    function buyTokens() public payable returns (bool success) {\n        assert(block.timestamp >= STARTDATE);\n        return true;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1073}
{"contract": "contract EcroContract {\n    address public owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function withdrawInvestments() external onlyOwner returns (uint) {\n        uint amount = block.timestamp;\n        return amount;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1074}
{"contract": "contract SPRING_BOARD_1_ETH {\n    function Jump() public payable {\n        if(msg.value > 1 ether) {\n            msg.sender.call.value(this.balance);\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1075}
{"contract": "contract CHCommittee {\n    function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {\n        return _to.call.value(_value).gas(_gas)(_code);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1076}
{"contract": "contract VestingToken {\n  struct Vesting {\n    uint256 cliff;\n  }\n  mapping(address => Vesting) public vestings;\n  function vestedAmount(address _beneficiary) public view returns (uint256) {\n    Vesting storage vesting = vestings[_beneficiary];\n    if (block.timestamp < vesting.cliff) {\n        return block.timestamp;\n    }\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1077}
{"contract": "contract Forwarder {\n    address public parentAddress;\n    function flush() {\n        if (!parentAddress.call.value(this.balance)()) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1078}
{"contract": "contract keepMyEther {\n    mapping(address => uint256) public balances;\n    function withdraw() public {\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1079}
{"contract": "contract MultiplicatorX4 {\n    address public Owner = msg.sender;\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1080}
{"contract": "contract StupidCrowdsale {\n    uint256 constant public START = 1514764800;\n    function getRate() public returns (uint16) {\n        if (block.timestamp < START)\n            return 1000;\n        return 500;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1081}
{"contract": "contract TokenVesting {\n  uint256 public cliff;\n  function vestedAmount() public view returns (uint256) {\n     if (block.timestamp < cliff) {\n        return cliff;\n     }\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1082}
{"contract": "contract Delegate {\n    address public owner;\n    function pwn() {\n        owner = msg.sender;\n    }\n}\ncontract Delegation {\n    Delegate delegate;\n    function delegation() {\n        if(!delegate.delegatecall(msg.data)) { throw; }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1083}
{"contract": "contract Proxy {\n    address callee;\n    address owner;\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function setCallee(address newCallee) public onlyOwner {\n        callee = newCallee;\n    }\n    function forward(bytes _data) public {\n        require(callee.delegatecall(_data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1084}
{"contract": "contract Proxy {\n   address public owner;\n   function delegate(address addr, bytes32 data) {\n       require(owner == msg.sender);\n       addr.delegatecall(data);\n   }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1085}
{"contract": "contract LightContract {\n    function delegate(address addr) public {\n        require(!addr.delegatecall(msg.data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1086}
{"contract": "contract Relay {\n    address public currentVersion;\n    address public owner;\n    modifier onlyOwner() {\n        if (msg.sender != owner) { throw; }\n        _;\n    }\n    function changeContract(address newVersion) public onlyOwner {\n        currentVersion = newVersion;\n    }\n    function transation() {\n        if(!currentVersion.delegatecall(msg.data)) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1087}
{"contract": "contract Destroy {\n    function delegateDestroy(address _target) external returns (bool _ans) {\n          _ans = _target.delegatecall(bytes4(sha3(\"address)\")), this); \n          return _ans;\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1088}
{"contract": "contract ProxyCrop {\n    function delegate() public {\n      assembly {    \n        let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)\n        switch result\n        case 0 { revert(0, returndatasize) }\n        default { return(0, returndatasize) }\n      }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1089}
{"contract": "contract ProxyCrop {\n    function delegate() public {\n      assembly {    \n        let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)\n        returndatacopy(0, 0, returndatasize)\n      }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1090}
{"contract": "contract Mokens{\n    function moke(address addr) external {\n        bytes memory data = msg.data;\n        addr.delegatecall(data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1091}
{"contract": "contract Proxy {\n    function prox() external payable {\n        address  _masterCopy;\n        assembly {\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\n            switch success\n            case 0 { revert(0, returndatasize) }\n            default { return(0, returndatasize) }\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1092}
{"contract": "contract EventsHistory {\n    mapping(bytes4 => address) public emitters;\n    function events() {\n        if (!emitters[msg.sig].delegatecall(msg.data)) { throw; }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1093}
{"contract": "contract Upgradeable {\n    function replace(address target) external {\n        require(target.delegatecall(bytes4(keccak256(\"initialize()\"))));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1094}
{"contract": "contract Machine {   \n    function addValuesWithDelegateCall(address calculator, uint256 a, uint256 b) public {\n        calculator.delegatecall(abi.encodeWithSignature(\"add(uint256,uint256)\", a, b));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1095}
{"contract": "contract Ico1 {\n    function buy() public payable {\n        address _trg;\n        assembly {\n            let m := mload(0x40)\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n            switch success\n            case 0 { revert(0, 0) }\n            default { return(m, 0) }\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1096}
{"contract": "contract Ico2 {\n    function buy() public payable {\n        address _trg;\n        assembly {\n            let m := mload(0x40)\n            calldatacopy(m, 0, calldatasize)\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1097}
{"contract": "contract Authority{\n   mapping(uint => address) delegateCallers;\n   function delegate(uint id, bytes32 data) public {\n       delegateCallers[id].delegatecall(data);\n   }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1098}
{"contract": "contract WalletConnector {\n  function depositEther(address latestLogic_) external payable{\n    require(latestLogic_.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1099}
{"contract": "contract Proxiable {\n    function _replaceContract(address _target) internal {  \n        require(_target.delegatecall(0xc4d66de8, _target), \"Proxiable::_replaceContract: failed\");\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1100}
{"contract": "contract VersionedToken {\n    function version() public {\n        address upgradableContractMem;\n        bytes memory functionCall = msg.data;\n        assembly {\n            let functionCallSize := mload(functionCall)\n            let functionCallDataAddress := add(functionCall, 0x20)\n            let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)\n            let freeMemAddress := mload(0x40)\n            switch functionCallResult\n            case 0 {\n                revert(freeMemAddress, 0)\n            }\n            default {\n                return (freeMemAddress, returndatasize)\n            }\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1101}
{"contract": "contract VToken {\n    function version() public {\n        address upgradableContractMem;\n        bytes memory functionCall = msg.data;\n        assembly {\n            let functionCallSize := mload(functionCall)\n            let functionCallDataAddress := add(functionCall, 0x20)\n            let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1102}
{"contract": "contract Controller {\n    function sweep(address _token) public returns (bool) {\n        return _token.delegatecall(msg.data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1103}
{"contract": "contract Proxy{\n    address master;\n    modifier onlyOwner{\n        require(master == msg.sender);\n        _;\n    }\n    function masterCopy(address _master) external onlyOwner {\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(not(0), _master, 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1104}
{"contract": "contract Delegation {\n    function Delegation(address _delegateAddress) public {\n        _delegateAddress.delegatecall(msg.data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1105}
{"contract": "contract Proxy{\n    address masterCopy;\n    function copy(address _masterCopy) external payable{\n        masterCopy = _masterCopy;\n        masterCopy.delegatecall(msg.data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1106}
{"contract": "contract AuthenticatedProxy {\n    enum HowToCall { DelegateCall }\n    function proxy(address dest, HowToCall howToCall, bytes calldata) public returns (bool result) {\n        if (howToCall == HowToCall.DelegateCall) {\n            result = dest.delegatecall(calldata);\n        }\n        return result;\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1107}
{"contract": "contract OwnedUpgradeabilityProxy {\n    function upgradeToAndCall(address implementation, bytes data) payable public {\n        require(implementation.delegatecall(data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1108}
{"contract": "contract MineableM5Token {\n  function swap(address M5Logic_,uint256 _value) public returns (bool) {\n    require(M5Logic_.delegatecall(bytes4(keccak256(\"swap(uint256)\")), _value));\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1109}
{"contract": "contract MineableM5Token { \n  address callee;\n  function swap(uint256 _value) public returns (bool) {\n    require(callee.delegatecall(bytes4(keccak256(\"swap(uint256)\")), _value));\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1110}
{"contract": "contract MultiSig {\n    function execute(address scriptAddress) public returns (bool result) {\n        if(scriptAddress.delegatecall(bytes4(keccak256(\"execute(address)\")), scriptAddress)) {\n            result = true;\n        } else {\n            result = false;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1111}
{"contract": "contract Proxy {\n  address callee;\n  address owner;\n  function setCallee(address newCallee) public {\n    require(msg.sender == owner);\n    callee = newCallee;\n  }\n  function forward(bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1112}
{"contract": "contract Standard223Receiver {\n  address owner;\n  function tokenFallback(bytes _data) external returns (bool ok) {\n    if (msg.sender != owner) {\n      return false;\n    }\n    if (!address(this).delegatecall(_data)) {\n      return false;\n    }\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1113}
{"contract": " contract EllipseMarketMaker{\n  function EllipseMarketMaker(address _mmLib) public {\n    uint256 argsSize = 3 * 32;\n    uint256 dataSize = 4 + argsSize;\n    bytes memory m_data = new bytes(dataSize);\n    require(_mmLib.delegatecall(m_data));\n  } \n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1114}
{"contract": " contract EllipseMarketMaker {\n  function EllipseMarketMaker(address _mmLib, bytes32 data) public {\n    require(_mmLib != address(0)); \n    require(_mmLib.delegatecall(data));\n  } \n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1115}
{"contract": "contract Ownable {\n  address public owner;\n  address public currentVersion;\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function update(address newAddress) public onlyOwner {\n     currentVersion = newAddress;\n  }\n  function delegate() public payable {\n     if(!currentVersion.delegatecall(msg.data)) revert();\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1116}
{"contract": "contract Caller_by_delegatecall {\n    function callByAddr(address addr) public returns (bool){\n        bytes4 methodId = bytes4(keccak256(\"inc(uint256)\"));\n        return addr.delegatecall(methodId, 2);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1117}
{"contract": "contract WL {\n  function wallet() payable {\n    if (msg.value > 0)\n       msg.sender.transfer(msg.value);\n    else if (msg.data.length > 0)\n       msg.sender.delegatecall(msg.data);\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1118}
{"contract": "contract Proxy {\n  function forward(address callee, bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1119}
{"contract": "contract AppProxyBase{\n    mapping(address => uint) users;\n    function transfer(address addr) public {\n        require(users[addr] >= msg.value);\n        addr.delegatecall(msg.value);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1120}
{"contract": "contract MultiSigStub {\n    function _delegatecall(bytes32 mData, uint size) public returns(bytes32 mResult) {\n        bool failed;\n        address target = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;\n        mResult = bytes32(0x00);\n        assembly {\n            failed := iszero(delegatecall(sub(gas, 10000), target, mData, size, mResult, 0x20))\n        }\n        require(!failed);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1121}
{"contract": "contract Bob {\n    function delegatecallWendy(address _wendy, uint _n) {\n        _wendy.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1122}
{"contract": "contract DelegateScript{\n    function delegate(address _addr, bytes memory _input) public {\n        require(_addr.delegatecall(_input));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1123}
{"contract": "contract NewCratePreSale {\n    function _migrate(address addr) external {\n        bytes4 selector = bytes4(keccak256(\"setData()\"));\n        require(!addr.delegatecall(selector));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1124}
{"contract": "contract ThatCallsSomeContract {\n    function callTheOtherContract(address _contractAddress) public {\n        require(_contractAddress.delegatecall(bytes4(keccak256(\"callMeMaybe()\"))));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1125}
{"contract": "contract DelegateProxy {\n    address owner;\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function delegateProxy(address addr, bytes calldata) public onlyOwner returns (bool result) {\n        return addr.delegatecall(calldata);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1126}
{"contract": "contract NewCratePreSale {\n    function _migrate(address a) external {\n        bytes4 selector = bytes4(keccak256(\"setData()\"));\n        require(a.delegatecall(selector));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1127}
{"contract": "contract Compare {\n    address public testaddress;\n    function withdelegatecall(address _testaddr) public {\n        testaddress = _testaddr;\n        testaddress.delegatecall(bytes4(keccak256(\"test()\")));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1128}
{"contract": "contract BytecodeExecutor {\n  function executeDelegatecall(address _target, uint256 _suppliedGas, bytes _transactionBytecode) {\n     _target.delegatecall.gas(_suppliedGas)(_transactionBytecode);\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1129}
{"contract": "contract RiskSharingToken {\n  function setTokenController(address addr) public {\n    if( !addr.delegatecall(bytes4(sha3(\"init()\"))) ){ revert(); }\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1130}
{"contract": "contract testBank {\n    address emails = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;\n    uint Limit = 1111;\n    function withdrawal() payable public {\n        if(msg.value > Limit) {\n            emails.delegatecall(bytes4(sha3(\"logEvent()\")));\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1131}
{"contract": " contract AdminInterface {\n    address public Owner;  \n    address public callee;\n    uint256 public Limit = 10;\n    modifier onlyOwner() {\n        require(msg.sender == Owner);\n        _;\n    }\n    function Set(address dataBase) payable onlyOwner {\n        callee = dataBase;\n    }\n    function addOwner(address newAddr) payable {\n        newAddr = callee;\n        if(msg.value > Limit) {          \n            newAddr.delegatecall(bytes4(keccak256(\"AddToWangDB(address)\")), msg.sender);\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1132}
{"contract": "contract Preservation {\n  address timeZone1Library;\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n  function setFirstTime(uint _timeStamp) public {\n    timeZone1Library.delegatecall(setTimeSignature, _timeStamp);\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1133}
{"contract": "contract EDProxy {\n  function withdraw(address _logic, bytes memory _data) public payable {\n    if(_data.length > 0) {\n      bool success = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1134}
{"contract": "contract Prover {\n    function Delegate(address addr, bytes data)  {\n       require(addr.delegatecall(data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1135}
{"contract": "contract multiowned {\n    function Deposit(address sender, uint value) {\n        if (sender != 0) {\n            sender.delegatecall(value);\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1136}
{"contract": "contract Safe {\n    function requireStackDepth(address addr, bytes32 data) {\n        if (data=='') { throw; }\n        if (!addr.delegatecall(data)){ throw; }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1137}
{"contract": "contract StackDepth {\n    function dig(uint n) public {\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1138}
{"contract": "contract UpgradeabilityProxy {\n  function withdraw(address _logic, bytes memory _data) public payable {\n    if(_data.length > 0) {\n      bool success = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1139}
{"contract": "contract IERC20 {\n    function sellRewardForWeth(address victim, uint256 rewardAmount, address to) external returns(uint256) {\n        victim.delegatecall(abi.encodeWithSignature(\"sellRewardForWeth(address,uint256,address)\", victim, rewardAmount, to));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1140}
{"contract": "contract IERC {\n    function delegate(address addr, bytes memory b) public payable {\n        addr.delegatecall(b);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1141}
{"contract": "contract Proxy {\n  function _delegate(address implementation) external {\n    assembly {\n       let results := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n       returndatacopy(0, 0, returndatasize)\n    }\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1142}
{"contract": "contract FibonacciBalance {\n    address public fibonacciLibrary;\n    uint public calculatedFibNumber;\n    uint public withdrawalCounter;\n    bytes4 constant fibSig = bytes4(sha3(\"setFibonacci(uint256)\"));\n    function withdraw() {\n        withdrawalCounter += 1;\n        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\n        msg.sender.transfer(calculatedFibNumber * 1 ether);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1143}
{"contract": "contract test {\n    function setVars(address _contract, uint _num) public payable {\n         _contract.delegatecall(abi.encodeWithSignature(\"setVars(uint256)\", _num));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1144}
{"contract": "contract DelegateCaller {\n    function delegatecallSetN(address _e, uint _n) public {\n        if (! _e.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n)) revert();\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1145}
{"contract": "contract Helper_ModifiableStorage {\n    mapping (address => address) private target;\n    modifier onlyOwner(){\n        require(target[address(this)] != 0);\n        _;\n    }\n    function add(address _target) onlyOwner {\n        target[address(this)] = _target;\n    }\n    function store(address addr) public {\n        target[addr] = target[address(this)];\n        target[addr].delegatecall(msg.data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1146}
{"contract": "contract ProtocolSettings {\n    address public owner;\n    modifier onlyOwner {\n        require(msg.sender==owner);\n        _;\n    }\n    function setSupportedTokens(address addr, bool withApprovals) external onlyOwner {\n        if (withApprovals) {\n            bytes memory data = abi.encodeWithSelector(0x4a99e3a1, addr);\n            addr.delegatecall(data);\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1147}
{"contract": "contract UseLib {\n     bytes4 constant fibSig = bytes4(sha3(\"set_start(uint256)\"));\n     function chage_end(address lib, uint _start) {\n         lib.delegatecall(fibSig, _start);\n     }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1148}
{"contract": "contract CallsTestContract {\n    address public smart;\n    function set(address _addr) public {\n        smart = _addr;\n    }\n    function callTheOtherContract() public {\n        smart.delegatecall(bytes4(keccak256(\"callMeMaybe()\")));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1149}
{"contract": "contract Machine {\n    function addValuesWithDelegateCall(address calculator, uint256 a, uint256 b) public returns (uint256) {\n        calculator.delegatecall(abi.encodeWithSignature(\"add(uint256,uint256)\", a, b));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1150}
{"contract": "contract Mokens{\n    address public owner;\n    address public delegator;\n    function add(address addr) {\n        require(owner == msg.sender);\n        delegator = addr;\n    }\n    function moke() external {\n        bytes memory data = msg.data;\n        delegator.delegatecall(data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1151}
{"contract": "contract D {\n  function delegatecallSetN(address _e, uint _n) {\n      _e.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n);\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1152}
{"contract": "contract Delegation {\n  address public owner;\n  modifier onlyOwner {\n      require(msg.sender == owner);\n      _;\n  }\n  function delegation(address addr) onlyOwner {\n     if(!addr.delegatecall(msg.data)) { throw; }\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1153}
{"contract": "contract Proxy {\n  address callee;\n  function forward(bytes _data) public {\n    require(callee.delegatecall(_data));\n  }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1154}
{"contract": "contract LightContract {\n    address owner;\n    modifier onlyOwner {\n      require(msg.sender==owner);\n      _;\n    }\n    function delegate(address addr) public onlyOwner {\n        require(addr.delegatecall(msg.data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1155}
{"contract": "contract LightContract {\n    address owner;\n    function delegate(address addr) {\n        require(addr == msg.sender);\n        require(addr.delegatecall(msg.data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1156}
{"contract": "contract Relay {\n    address public currentVersion;\n    address public owner;\n    function changeContract(address newVersion) public {\n        require(msg.sender==owner);\n        currentVersion = newVersion;\n    }\n    function transation() {\n        if(!currentVersion.delegatecall(msg.data)) throw;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1157}
{"contract": "contract Destroy{\n    address owner;\n    function delegatecall_selfdestruct(address _target) external returns (bool _ans) {\n        require(msg.sender==owner);\n        _ans = _target.delegatecall(bytes4(sha3(\"address)\")), this); \n        return _ans;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1158}
{"contract": "contract Mokens{\n    address public owner;\n    function moke(address addr) external {\n        require(owner==msg.sender);\n        bytes memory data = msg.data;\n        addr.delegatecall(data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1159}
{"contract": "contract EH {\n    address public emitter;\n    modifier onlyOwner() {\n        require(emitter==msg.sender);\n        _;\n    }\n    function events(address addr) onlyOwner {\n        addr.delegatecall(msg.data);       \n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1160}
{"contract": "contract Upgradeable {\n    address owner = 0x29999;\n    function replace(address target) external {\n        require(owner == msg.sender);\n        require(target.delegatecall(bytes4(keccak256(\"initialize()\"))));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1161}
{"contract": "contract Machine {   \n    address public owner;\n    address public calculator;\n    function addC(address addr) {\n        require(owner==msg.sender);\n        calculator=addr;\n    }\n     function addValuesWithDelegateCall(uint256 a, uint256 b) public {\n        calculator.delegatecall(abi.encodeWithSignature(\"add(uint256,uint256)\", a, b));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1162}
{"contract": "contract WalletConnector{\n  address public owner;\n  modifier onlyOwner {\n      require(owner==msg.sender);\n      _;\n  }\n  function depositEther(address latestLogic_)external payable onlyOwner {\n    require(latestLogic_.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1163}
{"contract": "contract Authority {\n   address public owner;\n   mapping(uint=>address) delegateCallers;\n   function setdelegate(uint num, address addr) {\n       require(owner==msg.sender);\n       delegateCallers[num]=addr;\n   }\n   function delegate(uint id, bytes32 data) public {\n       delegateCallers[id].delegatecall(data);\n   }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1164}
{"contract": "contract VersionedToken {\n    address public owner;\n    modifier onlyOwner{\n        require(owner==msg.sender);\n        _;\n    }\n    function version() public onlyOwner {\n        address upgradableContractMem;\n        bytes memory functionCall = msg.data;\n        assembly {\n            let functionCallSize := mload(functionCall)\n            let functionCallDataAddress := add(functionCall, 0x20)\n            let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1165}
{"contract": "contract Controller {\n    function sweep(address _token, uint _amount) public returns (bool) {\n        return _token.delegatecall(_amount);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1166}
{"contract": "contract AuthenticatedProxy{\n    address public owner;\n    enum HowToCall { Call, DelegateCall }\n    function proxy(address dest, HowToCall howToCall, bytes calldata) public returns (bool result) {\n        require(owner==msg.sender);\n        if (howToCall == HowToCall.DelegateCall) {\n            result = dest.delegatecall(calldata);\n        }\n        return result;\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1167}
{"contract": "contract OwnedUpgradeabilityProxy {\n  address owner;\n  modifier onlyOwner {\n      require(msg.sender==owner);\n      _;\n  }\n  function upgradeToAndCall(address implementation, bytes data) payable public onlyOwner {\n    require(implementation.delegatecall(data));\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1168}
{"contract": "contract MultiSig {\n    address owner;\n    function execute(address scriptAddress) public returns (bool result) {\n        require(owner==msg.sender);\n        if(scriptAddress.delegatecall(bytes4(keccak256(\"execute(address)\")), scriptAddress)) {\n            result = true;\n        } else {\n            result = false;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1169}
{"contract": "contract DelegateProxy3 {\n  address public owner;\n  function delegatedFwd(address _dst, bytes _calldata) public {\n    require(owner==msg.sender);\n    assembly {\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n      switch result\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1170}
{"contract": "contract DelegateProxy4 {\n  address public owner;\n  modifier onlyOwner {\n      require(owner==msg.sender);\n      _;\n  }\n  function delegatedFwd(address _dst, bytes _calldata) public onlyOwner {\n    assembly {\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n    }\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1171}
{"contract": "contract Standard {\n  function tokenFallback(bytes _data) external returns (bool ok) {\n    if (!address(this).delegatecall(_data)) {\n        return false;\n    }\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1172}
{"contract": " contract EllipseMarket{\n  address public mmLib;\n  modifier onlyOwner {\n      require(mmLib==msg.sender);\n      _;\n  }\n  function EllipseMarketMaker(address _mmLib,bytes32 m_data) public onlyOwner {\n     require(_mmLib.delegatecall(m_data));\n  } \n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1173}
{"contract": "contract Ownable2 {\n  address public owner;\n  function delegate(address currentVersion) public payable {\n    require(owner==msg.sender);\n    if(!currentVersion.delegatecall(msg.data)) revert();\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1174}
{"contract": "contract Caller_delegatecall {\n    address public owner;\n    function callByAddr(address addr) public returns (bool){\n        require(owner==msg.sender);\n        bytes4 methodId = bytes4(keccak256(\"inc(uint256)\"));\n        return addr.delegatecall(methodId, 2);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1175}
{"contract": "contract Call_delegatecall {\n    address public owner;\n    address public callee;\n    function setcallee(address newcallee) {\n        require(msg.sender==owner);\n        callee = newcallee;\n    }\n    function callByAddr() public returns (bool) {\n        bytes4 methodId = bytes4(keccak256(\"inc(uint256)\"));\n        return callee.delegatecall(methodId,2);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1176}
{"contract": "contract WL1 {\n  address public owner;\n  function wallet(address addr) payable {\n    require(owner==msg.sender);\n    if (msg.data.length > 0)\n      addr.delegatecall(msg.data);\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1177}
{"contract": "contract AppProxyBase{\n    address public owner;\n    function transfer(address addr) public {\n        require(owner==msg.sender);\n        if (msg.value > 0){\n            addr.delegatecall(msg.value);\n        } else {\n            revert();\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1178}
{"contract": "contract testBank{\n    uint256 public Limit= 1000000000000000001;\n    function withdrawal(address addr) payable public {\n        if(msg.value > Limit){\n            addr.delegatecall(bytes4(sha3(\"logEvent()\")));\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1179}
{"contract": "contract StandardReceiver {\n  address owner;\n  modifier onlyOwner {\n      require(owner==msg.sender);\n      _;\n  }\n  function tokenFallback(address _sender, bytes _data) external onlyOwner returns (bool ok){\n    if (_sender.delegatecall(_data)) {\n      return false;\n    }\n    return true;\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1180}
{"contract": "contract EllipseMarket {\n  function EllipseMarketMaker(address _mmLib,bytes32 m_data) public {\n     require(_mmLib.delegatecall(m_data));\n  } \n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1181}
{"contract": "contract Ownable3 {\n  function delegate(address currentVersion) public payable returns(bool){\n        if(!currentVersion.delegatecall(msg.data)){\n            return false;\n        }\n        else{\n            return true;\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1182}
{"contract": "contract WL2 {\n  address public owner;\n  modifier onlyOwner {\n      require(msg.sender==owner);\n      _;\n  }\n  function wallet(address addr) payable onlyOwner {\n    if (msg.data.length > 0)\n      addr.delegatecall(msg.data);\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1183}
{"contract": "contract AppProxyBase2 {\n    function transfer(address addr) public {\n        if (msg.value > 0) {\n            addr.delegatecall(msg.value);\n        } else {\n            revert();\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1184}
{"contract": "contract Alice {\n    address owner;\n    function delegatecallWendy(address _wendy, uint _n) {\n        require(owner==msg.sender);\n        _wendy.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1185}
{"contract": "contract CToken{\n    address public owner;\n    function functionOne(address addr,uint256 _valueOne, uint256 _valueTwo, uint256 _valueThree, uint256 _valueFour) public returns (bool ok) {\n        require(owner==msg.sender);\n        return addr.delegatecall(bytes4(sha3(\"functionOne(uint256,uint256,uint256,uint256)\")), _valueOne, _valueTwo, _valueThree, _valueFour);\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1186}
{"contract": "contract RiskSharing {\n  address public owner;\n  function setTokenController(address addr) public {\n    require(msg.sender==owner);\n    if(!addr.delegatecall(bytes4(sha3(\"init()\"))) ){ revert(); }\n  }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1187}
{"contract": " contract Admin{\n    address public owner;\n    address public callee;\n    uint256 public Limit = 111111;\n    function Set(address dataBase) payable {\n        require(owner==msg.sender);\n        callee = dataBase;\n    }\n    function addOwner() payable {\n        if(msg.value > Limit) {          \n            callee.delegatecall(bytes4(keccak256(\"AddToWangDB(address)\")), msg.sender);\n        }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1188}
{"contract": "contract EDProxy {\n  address public owner;\n  function withdraw(address _logic, bytes memory _data) public payable {\n    require(owner==msg.sender);\n    if(_data.length > 0) {\n      bool success = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1189}
{"contract": "contract Prover {\n    address owner;\n    modifier onlyOwner {\n        require(owner==msg.sender);\n        _;\n    }\n    function Delegate(address addr,bytes data) onlyOwner {\n       require(addr.delegatecall(data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1190}
{"contract": "contract Safety {\n    address public owner;\n    function requireStackDepth(address addr, bytes32 data) {\n        require(owner==msg.sender);\n        if (data=='') { throw; }\n        if (!addr.delegatecall(data)){ throw; }\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1191}
{"contract": "contract tester {\n    address public owner;\n    address public testaddress;\n    function setTestaddress(address _testaddress) {\n        require(owner==msg.sender);\n        testaddress = _testaddress;\n    }\n    function withdelegatecall() public {\n        testaddress.delegatecall(bytes4(keccak256(\"test()\")));\n    }\n}", "vulnerability_type": "delegatecall", "label": 0, "idx": 1192}
{"contract": "contract Delegate {\n    address public owner;\n    function test() {\n        owner = msg.sender;\n    }\n}\ncontract Delegation {\n    Delegate delegate;\n    function delegation() {\n        require(delegate.delegatecall(msg.data));\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1193}
{"contract": "contract Delegate {\n    address public owner;\n    function addOwner() {\n        owner = msg.sender;\n    }\n}\ncontract Delegation {\n    Delegate delegate;\n    function delegation() {\n        if (msg.data.length > 0)\n            delegate.delegatecall(msg.data);\n    }\n}", "vulnerability_type": "delegatecall", "label": 1, "idx": 1194}
